library(randomForestExplainer)
# Chunk 32
m.lzn.rf <- randomForest(logZn ~ ffreq + x + y + dist.m + elev + soil + lime, data=meuse, importance=T, na.action=na.omit, mtry=5)
print(m.lzn.rf)
# Chunk 33
plot(m.lzn.rf)
# Chunk 34
n <- 24
rf.stats <- data.frame(rep=1:10, rsq=as.numeric(NA), mse=as.numeric(NA))
for (i in 1:n) {
model.rf <- randomForest(logZn ~ ffreq + x + y + dist.m + elev + soil + lime,
data=meuse, importance=T, na.action=na.omit, mtry=5)
summary(model.rf$rsq)
summary(model.rf$mse)
rf.stats[i, "mse"] <- median(summary(model.rf$mse))
rf.stats[i, "rsq"] <- median(summary(model.rf$rsq))
}
summary(rf.stats[,2:3])
hist(rf.stats[,"rsq"], xlab="RandomForest R^2")
rug(rf.stats[,"rsq"])
hist(rf.stats[,"mse"], xlab="RandomForest RMSE")
rug(rf.stats[,"mse"])
# Chunk 35
importance(m.lzn.rf, type=1)
importance(m.lzn.rf, type=2)
varImpPlot(m.lzn.rf, type=1)
# Chunk 36
min_depth_frame <- min_depth_distribution(m.lzn.rf)
str(min_depth_frame)  # has results for all the trees
plot_min_depth_distribution(min_depth_frame)
# Chunk 37
importance_frame <- measure_importance(m.lzn.rf)
print(importance_frame)
# Chunk 38
plot_importance_ggpairs(importance_frame)
# Chunk 39
plot_multi_way_importance(m.lzn.rf, size_measure = "no_of_nodes")
# Chunk 40
interactions_frame <- min_depth_interactions(m.lzn.rf)
interactions_frame[order(interactions_frame$occurrences, decreasing = TRUE)[1:12], ]
plot_min_depth_interactions(interactions_frame)
# Chunk 41
plot_predict_interaction(m.lzn.rf, meuse, "dist.m", "elev")
# Chunk 42
partialPlot(m.lzn.rf, pred.data=meuse, x.var="x")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="y")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="dist.m")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="elev")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="ffreq", which.class=1)
# Chunk 43
p.rf <- predict(m.lzn.rf, newdata=meuse)
length(unique(p.rf))
summary(r.rpp <- meuse$logZn - p.rf)
(rmse.rf <- sqrt(sum(r.rpp^2)/length(r.rpp)))
plot(meuse$logZn ~ p.rf, asp=1, pch=20, xlab="fitted", ylab="actual", xlim=c(2,3.3),          ylim=c(2,3.3), main="log10(Zn), Meuse topsoils, Random Forest")
grid()
abline(0,1)
# Chunk 44
p.rf.oob <- predict(m.lzn.rf)
summary(r.rpp.oob <- meuse$logZn - p.rf.oob)
(rmse.oob <- sqrt(sum(r.rpp.oob^2)/length(r.rpp.oob)))
plot(meuse$logZn ~ p.rf.oob, asp=1, pch=20,
xlab="Out-of-bag cross-validation estimates",
ylab="actual", xlim=c(2,3.3), ylim=c(2,3.3),
main="log10(Zn), Meuse topsoils, Random Forest")
grid()
abline(0,1)
# Chunk 45
names(meuse.grid)
m.lzn.rf.g <- randomForest(logZn ~ x + y + ffreq + dist + soil, data=meuse, importance=T, na.action=na.omit, mtry=3)
print(m.lzn.rf)
(tmp <- importance(m.lzn.rf.g, type=1))
(100*tmp/sum(tmp))
varImpPlot(m.lzn.rf.g, type=1)
# Chunk 46
meuse.grid.sp$predictedLog10Zn.rf <- predict(m.lzn.rf.g, newdata=meuse.grid)
spplot(meuse.grid.sp, zcol="predictedLog10Zn.rf")
# Chunk 47
library(Cubist)
# Chunk 48
inTrain <- sample(1:nrow(meuse), floor(.8*nrow(meuse)))
# Chunk 49
preds <- c("x","y","ffreq","dist.m","elev","soil","lime")
train.pred <- meuse[ inTrain, preds]
test.pred  <- meuse[-inTrain, preds]
train.resp <- meuse$logZn[ inTrain]
test.resp  <- meuse$logZn[-inTrain]
# Chunk 50
(c.model <- cubist(x = train.pred, y = train.resp))
summary(c.model)
# Chunk 51: bh3
c.pred <- predict(c.model, test.pred)
## Test set RMSE
sqrt(mean((c.pred - test.resp)^2))
## Test set R^2
cor(c.pred, test.resp)^2
# Chunk 52
preds <- c("x","y","dist","soil","ffreq")
all.preds <- meuse[, preds]
all.resp <- meuse$logZn
c.model.grid <- cubist(x = all.preds, y = all.resp)
summary(c.model.grid)
meuse.grid.sp$predictedLog10Zn.cubist <- predict(c.model.grid, newdata=meuse.grid[,preds])
spplot(meuse.grid.sp, zcol="predictedLog10Zn.cubist", col.regions=bpy.colors(64))
# Chunk 53
require(caret)
test <- train(x = all.preds, y = all.resp, method="cubist",
tuneGrid = expand.grid(.committees = 1:12,
.neighbors = 0:5),
trControl = trainControl(method = 'cv'))
install.packages("Cubist")
knitr::opts_chunk$set(fig.width=4, fig.height=6, fig.align='center',
fig.path='rmdfigs/exMeuseTreesForests_',
warning=FALSE, message=FALSE)
writeLines(capture.output(sessionInfo()), "sessionInfo.txt")
library(sp)
data(meuse)
str(meuse)
meuse$logZn <- log10(meuse$zinc)    # 锌
meuse$logCu <- log10(meuse$copper)  # 铜
meuse$logPb <- log10(meuse$lead)    # 铅
meuse$logCd <- log10(meuse$cadmium) # 镉
data(meuse.grid)
str(meuse.grid)
library(sp)
library(rpart)
library(rpart.plot)
install.packages("rpart.plot")
library(sp)
library(rpart)
library(rpart.plot)
names(meuse)
names(meuse.grid)
help(rpart.control)
m.lzn.rp <- rpart(logZn ~ x + y + ffreq + dist.m + soil + lime + elev,
data=meuse,
minsplit=2,
cp=0.005)
print(m.lzn.rp)
rpart.plot(m.lzn.rp, digits=3, type=4, extra=1)
print(tmp <- m.lzn.rp$variable.importance)
data.frame(variableImportance = 100 * tmp / sum(tmp))
plotcp(m.lzn.rp)
cp.table <- m.lzn.rp[["cptable"]]
cp.ix <- which.min(cp.table[,"xerror"])
print(cp.table[cp.ix,])
cp.min <- cp.table[cp.ix,"CP"]
(m.lzn.rpp <- prune(m.lzn.rp, cp=cp.min))
rpart.plot(m.lzn.rpp, digits=3, type=4, extra=1)
p.rpp <- predict(m.lzn.rpp, newdata=meuse)
length(unique(p.rpp))
summary(r.rpp <- meuse$logZn - p.rpp)
sqrt(sum(r.rpp^2)/length(r.rpp))
plot(meuse$logZn ~ p.rpp, asp=1, pch=20, xlab="fitted", ylab="actual", xlim=c(2,3.3), ylim=c(2,3.3), main="log10(Zn), Meuse topsoils, Regression Tree")
grid()
abline(0,1)
m.ff.rp <- rpart(ffreq ~ x + y + dist.m + elev,
data=meuse,
minsplit=2,
cp=0.02)
print(m.ff.rp)
rpart.plot(m.ff.rp)
printcp(m.ff.rp)
plotcp(m.ff.rp)
cp.table.class <- m.ff.rp[["cptable"]]
cp.ix <- which.min(cp.table.class[,"xerror"])
print(cp.table.class[cp.ix,])
(cp.min <- cp.table.class[cp.ix,"CP"])
m.ff.rpp <- prune(m.ff.rp, cp=cp.min)
print(m.ff.rpp)
rpart.plot(m.ff.rpp, type=2, extra=1)
m.ff.rp$variable.importance
m.ff.rpp$variable.importance
names(meuse.grid)
m.lzn.g <- rpart(logZn ~ x + y +  ffreq + dist + soil,
data=meuse,
minsplit=2,
cp=0.005)
plotcp(m.lzn.g)
rpart.plot(m.lzn.g, digits=3, type=4, extra=1)
cp.table <- m.lzn.g[["cptable"]]
cp.table[cp.ix <- which.min(cp.table[,"xerror"]),]
(cp.min <- cp.table[cp.ix,"CP"])
m.lzn.gp <- prune(m.lzn.g, cp=cp.min)
rpart.plot(m.lzn.gp)
print(tmp <- m.lzn.gp$variable.importance)
data.frame(variableImportance = 100 * tmp / sum(tmp))
meuse.grid.sp <- meuse.grid
coordinates(meuse.grid.sp) <- ~ x + y; gridded(meuse.grid.sp) <- TRUE
meuse.grid.sp$predictedLog10Zn <- predict(m.lzn.gp, newdata=meuse.grid)
spplot(meuse.grid.sp, zcol="predictedLog10Zn")
meuse.140.ix <- sample(1:dim(meuse)[1], size=140, replace=FALSE)
meuse.140 <- meuse[meuse.140.ix,]
m.lzn.rp.140 <- rpart(logZn ~ x + y + ffreq + dist.m + soil +  lime + elev,
data=meuse.140,
minsplit=2,
cp=0.005)
rpart.plot(m.lzn.rp.140, digits=3, type=4, extra=1)
print(tmp <- m.lzn.rp.140$variable.importance)
data.frame(variableImportance = 100 * tmp / sum(tmp))
plotcp(m.lzn.rp.140)
cp.table <- m.lzn.rp.140[["cptable"]]
cp.ix <- which.min(cp.table[,"xerror"])
print(cp.table[cp.ix,])
cp.min <- cp.table[cp.ix,"CP"]
m.lzn.rpp.140 <- prune(m.lzn.rp.140, cp=cp.min)
rpart.plot(m.lzn.rpp.140, digits=3, type=4, extra=1)
m.lzn.g.140 <- rpart(logZn ~ x + y + ffreq + dist + soil,
data=meuse.140,
minsplit=2,
cp=0.005)
plotcp(m.lzn.g.140)
rpart.plot(m.lzn.g.140, digits=3, type=4, extra=1)
cp.table <- m.lzn.g.140[["cptable"]]
cp.table[cp.ix <- which.min(cp.table[,"xerror"]),]
(cp.min <- cp.table[cp.ix,"CP"])
m.lzn.gp.140 <- prune(m.lzn.g.140, cp=cp.min)
rpart.plot(m.lzn.gp.140)
print(tmp <- m.lzn.gp.140$variable.importance)
data.frame(variableImportance = 100 * tmp / sum(tmp))
meuse.grid.sp$predictedLog10Zn.140 <- predict(m.lzn.gp.140, newdata=meuse.grid)
spplot(meuse.grid.sp, zcol="predictedLog10Zn.140")
meuse.grid.sp$predictedLog10Zn.diff <-
meuse.grid.sp$predictedLog10Zn - meuse.grid.sp$predictedLog10Zn.140
summary(meuse.grid.sp$predictedLog10Zn.diff)
spplot(meuse.grid.sp, zcol="predictedLog10Zn.diff", col.regions=topo.colors(36))
meuse.omitted <- meuse[-meuse.140.ix,]
plot(y ~ x, data=meuse.omitted, asp=1,
cex=2*meuse.omitted$logZn/max(meuse.omitted$logZn))
data(meuse.riv)
lines(meuse.riv)
grid()
library(randomForest)
library(randomForestExplainer)
m.lzn.rf <- randomForest(logZn ~ ffreq + x + y + dist.m + elev + soil + lime, data=meuse, importance=T, na.action=na.omit, mtry=5)
print(m.lzn.rf)
plot(m.lzn.rf)
n <- 24
rf.stats <- data.frame(rep=1:10, rsq=as.numeric(NA), mse=as.numeric(NA))
for (i in 1:n) {
model.rf <- randomForest(logZn ~ ffreq + x + y + dist.m + elev + soil + lime,
data=meuse, importance=T, na.action=na.omit, mtry=5)
summary(model.rf$rsq)
summary(model.rf$mse)
rf.stats[i, "mse"] <- median(summary(model.rf$mse))
rf.stats[i, "rsq"] <- median(summary(model.rf$rsq))
}
summary(rf.stats[,2:3])
hist(rf.stats[,"rsq"], xlab="RandomForest R^2")
rug(rf.stats[,"rsq"])
hist(rf.stats[,"mse"], xlab="RandomForest RMSE")
rug(rf.stats[,"mse"])
importance(m.lzn.rf, type=1)
importance(m.lzn.rf, type=2)
varImpPlot(m.lzn.rf, type=1)
min_depth_frame <- min_depth_distribution(m.lzn.rf)
str(min_depth_frame)  # has results for all the trees
plot_min_depth_distribution(min_depth_frame)
install.packages("randomForestExplainer")
min_depth_frame <- min_depth_distribution(m.lzn.rf)
str(min_depth_frame)  # has results for all the trees
plot_min_depth_distribution(min_depth_frame)
library(randomForest)
library(randomForestExplainer)
min_depth_frame <- min_depth_distribution(m.lzn.rf)
str(min_depth_frame)  # has results for all the trees
plot_min_depth_distribution(min_depth_frame)
importance_frame <- measure_importance(m.lzn.rf)
print(importance_frame)
plot_importance_ggpairs(importance_frame)
plot_multi_way_importance(m.lzn.rf, size_measure = "no_of_nodes")
interactions_frame <- min_depth_interactions(m.lzn.rf)
interactions_frame[order(interactions_frame$occurrences, decreasing = TRUE)[1:12], ]
plot_min_depth_interactions(interactions_frame)
plot_predict_interaction(m.lzn.rf, meuse, "dist.m", "elev")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="x")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="y")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="dist.m")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="elev")
partialPlot(m.lzn.rf, pred.data=meuse, x.var="ffreq", which.class=1)
p.rf <- predict(m.lzn.rf, newdata=meuse)
length(unique(p.rf))
summary(r.rpp <- meuse$logZn - p.rf)
(rmse.rf <- sqrt(sum(r.rpp^2)/length(r.rpp)))
plot(meuse$logZn ~ p.rf, asp=1, pch=20, xlab="fitted", ylab="actual", xlim=c(2,3.3),          ylim=c(2,3.3), main="log10(Zn), Meuse topsoils, Random Forest")
grid()
abline(0,1)
p.rf.oob <- predict(m.lzn.rf)
summary(r.rpp.oob <- meuse$logZn - p.rf.oob)
(rmse.oob <- sqrt(sum(r.rpp.oob^2)/length(r.rpp.oob)))
plot(meuse$logZn ~ p.rf.oob, asp=1, pch=20,
xlab="Out-of-bag cross-validation estimates",
ylab="actual", xlim=c(2,3.3), ylim=c(2,3.3),
main="log10(Zn), Meuse topsoils, Random Forest")
grid()
abline(0,1)
names(meuse.grid)
m.lzn.rf.g <- randomForest(logZn ~ x + y + ffreq + dist + soil, data=meuse, importance=T, na.action=na.omit, mtry=3)
print(m.lzn.rf)
(tmp <- importance(m.lzn.rf.g, type=1))
(100*tmp/sum(tmp))
varImpPlot(m.lzn.rf.g, type=1)
meuse.grid.sp$predictedLog10Zn.rf <- predict(m.lzn.rf.g, newdata=meuse.grid)
spplot(meuse.grid.sp, zcol="predictedLog10Zn.rf")
library(Cubist)
inTrain <- sample(1:nrow(meuse), floor(.8*nrow(meuse)))
preds <- c("x","y","ffreq","dist.m","elev","soil","lime")
train.pred <- meuse[ inTrain, preds]
test.pred  <- meuse[-inTrain, preds]
train.resp <- meuse$logZn[ inTrain]
test.resp  <- meuse$logZn[-inTrain]
(c.model <- cubist(x = train.pred, y = train.resp))
summary(c.model)
c.pred <- predict(c.model, test.pred)
## Test set RMSE
sqrt(mean((c.pred - test.resp)^2))
## Test set R^2
cor(c.pred, test.resp)^2
preds <- c("x","y","dist","soil","ffreq")
all.preds <- meuse[, preds]
all.resp <- meuse$logZn
c.model.grid <- cubist(x = all.preds, y = all.resp)
summary(c.model.grid)
meuse.grid.sp$predictedLog10Zn.cubist <- predict(c.model.grid, newdata=meuse.grid[,preds])
spplot(meuse.grid.sp, zcol="predictedLog10Zn.cubist", col.regions=bpy.colors(64))
require(caret)
test <- train(x = all.preds, y = all.resp, method="cubist",
tuneGrid = expand.grid(.committees = 1:12,
.neighbors = 0:5),
trControl = trainControl(method = 'cv'))
print(test)
plot(test, metric="RMSE")
plot(test, metric="Rsquared")
c.model.grid.2 <- cubist(x = all.preds, y = all.resp, committees=4)
summary(c.model.grid.2)
meuse.grid.sp$predictedLog10Zn.cubist.2 <-
predict(c.model.grid.2, newdata=meuse.grid[,preds],
neighbors=5)
summary(meuse.grid.sp$predictedLog10Zn.cubist.2)
spplot(meuse.grid.sp, zcol="predictedLog10Zn.cubist.2", col.regions=bpy.colors(64),
main="Optimized Cubist prediction")
c.model.grid$usage
c.model.grid.2$usage
caret::varImp(c.model.grid)
caret::varImp(c.model.grid.2)
setwd("~/Downloads")
library(ranger)
library(caret)
d <- read.csv("insts_cls_texSplines20190316.csv",header=TRUE)
str(d)
d$code <- as.character(d$code)
d$codeorg <- as.character(d$codeorg)
d$cls020 <- as.factor(d$cls020)
d$cls05 <- as.factor(d$cls05)
d$cls515 <- as.factor(d$cls515)
d$cls1530 <- as.factor(d$cls1530)
d$cls3060 <- as.factor(d$cls3060)
d$cls60100 <- as.factor(d$cls60100)
d$cls100200 <- as.factor(d$cls100200)
names(d)
d0 <- d[,-c(1:5)]
names(d0)
str(d0)
d020 <- d0[,-c(2:7)]
d020 <- d020[complete.cases(d020),]
names(d020)
ranger_tune_cls020 <- train(x=d020[,2:44],y=d020[,1], method="ranger",
tuneGrid=expand.grid(.mtry = 3:30,
.splitrule = "gini",
.min.node.size = 3:8,
.classification = TRUE),
trControl=trainControl(method = 'cv'))
ranger_tune_cls020 <- train(x=d020[,2:44],y=d020[,1], method="ranger",
tuneGrid=expand.grid(mtry = 3:30,
splitrule = "gini",
min.node.size = 3:8,
classification = TRUE),
trControl=trainControl(method = 'cv'))
ranger_tune_cls020 <- train(x=d020[,2:44],y=d020[,1], method="ranger",
tuneGrid=expand.grid(mtry = 3:30,
splitrule = "gini",
min.node.size = 3:8),
trControl=trainControl(method = 'cv'))
q
exit
abort
str(d)
dim(d)
d <- d[1:100,]
d$code <- as.character(d$code)
d$codeorg <- as.character(d$codeorg)
d$cls020 <- as.factor(d$cls020)
d$cls05 <- as.factor(d$cls05)
d$cls515 <- as.factor(d$cls515)
d$cls1530 <- as.factor(d$cls1530)
d$cls3060 <- as.factor(d$cls3060)
d$cls60100 <- as.factor(d$cls60100)
d$cls100200 <- as.factor(d$cls100200)
names(d)
d0 <- d[,-c(1:5)]
names(d0)
str(d0)
d020 <- d0[,-c(2:7)]
d020 <- d020[complete.cases(d020),]
names(d020)
ranger_tune_cls020 <- train(x=d020[,2:44],y=d020[,1], method="ranger",
tuneGrid=expand.grid(mtry = 3:30,
splitrule = "gini",
min.node.size = 3:8),
trControl=trainControl(method = 'cv'))
d <- read.csv("insts_cls_texSplines20190316.csv",header=TRUE)
str(d)
dim(d)
d <- d[1:100,]
d$code <- as.character(d$code)
d$codeorg <- as.character(d$codeorg)
d$cls020 <- as.factor(d$cls020)
d$cls05 <- as.factor(d$cls05)
d$cls515 <- as.factor(d$cls515)
d$cls1530 <- as.factor(d$cls1530)
d$cls3060 <- as.factor(d$cls3060)
d$cls60100 <- as.factor(d$cls60100)
d$cls100200 <- as.factor(d$cls100200)
names(d)
d0 <- d[,-c(1:5)]
names(d0)
str(d0)
###### cls020 ##########
# target depth 020cm
d020 <- d0[,-c(2:7)]
d020 <- d020[complete.cases(d020),]
names(d020)
ranger_tune_cls020 <- train(x=d020[,2:44],y=d020[,1], method="ranger",
tuneGrid=expand.grid(mtry = 3:30,
splitrule = "gini",
min.node.size = 3:8),
trControl=trainControl(method = 'cv'))
print(ranger_tune_cls020)
ranger_tune_cls020 <- train(x=d020[,2:44],y=d020[,1], method="ranger",
tuneGrid=expand.grid(.mtry = 3:30,
.splitrule = "gini",
.min.node.size = 3:8),
trControl=trainControl(method = 'cv'))
print(ranger_tune_cls020)
setwd("~/GitHub/ncss-tech/compare-psm")
ogr.d <- ogrDrivers()
ogr.d[ix <- which(ogr.d$name=="OpenFileGDB"), ]
library(rgdal)
ogr.d <- ogrDrivers()
ogr.d[ix <- which(ogr.d$name=="OpenFileGDB"), ]
# voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod")
df <- data.frame(voi.list.sg,
c("%%","%%","%%","pHx10","mmol(c)/kg",    "dg/kg",   "cg/cm3"),  #SG
c("%",  "%", "%",   "pH",          "", "log10(%)",    "g/cm3"),  # POLARIS
c("%%","%%","%%","pHx10","cmol(c)/kg",     "g/gF",    "Mg/m3"),  # GSM
c("%",  "%", "%",   "pH",          "",        "%",    "g/cm3"),  # SPCG100USA
c(  "%","%", "%","pHx10",          "",    "5g/Kg", "10 kg/m3"),  # LandGIS
c(  "%","%", "%",   "pH","cmol(+)/kg",         "",    "g/cm3"),  # ISSR-800
)
knitr::kable(
df, caption = 'Properties and units of measure',
col.names=c("Property","SoilGrids","POLARIS","GlobalSoilMap", "SPCG100USA", "LandGIS", "ISSR-800"),
booktabs = TRUE)
df <- data.frame(voi.list.sg,
c("%%","%%","%%","pHx10","mmol(c)/kg",    "dg/kg",   "cg/cm3"),  #SG
c("%",  "%", "%",   "pH",          "", "log10(%)",    "g/cm3"),  # POLARIS
c("%%","%%","%%","pHx10","cmol(c)/kg",     "g/gF",    "Mg/m3"),  # GSM
c("%",  "%", "%",   "pH",          "",        "%",    "g/cm3"),  # SPCG100USA
c(  "%","%", "%","pHx10",          "",    "5g/Kg", "10 kg/m3"),  # LandGIS
c(  "%","%", "%",   "pH","cmol(+)/kg",         "",    "g/cm3"),  # ISSR-800
)
df <- data.frame(voi.list.sg,
c("%%","%%","%%","pHx10","mmol(c)/kg",    "dg/kg",   "cg/cm3"),  #SG
c("%",  "%", "%",   "pH",          "", "log10(%)",    "g/cm3"),  # POLARIS
c("%%","%%","%%","pHx10","cmol(c)/kg",     "g/gF",    "Mg/m3"),  # GSM
c("%",  "%", "%",   "pH",          "",        "%",    "g/cm3"),  # SPCG100USA
c(  "%","%", "%","pHx10",          "",    "5g/Kg", "10 kg/m3"),  # LandGIS
c(  "%","%", "%",   "pH","cmol(+)/kg",         "",    "g/cm3"),  # ISSR-800
)
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod")
df <- data.frame(voi.list.sg,
c("%%","%%","%%","pHx10","mmol(c)/kg",    "dg/kg",   "cg/cm3"),  #SG
c("%",  "%", "%",   "pH",          "", "log10(%)",    "g/cm3"),  # POLARIS
c("%%","%%","%%","pHx10","cmol(c)/kg",     "g/gF",    "Mg/m3"),  # GSM
c("%",  "%", "%",   "pH",          "",        "%",    "g/cm3"),  # SPCG100USA
c(  "%","%", "%","pHx10",          "",    "5g/Kg", "10 kg/m3"),  # LandGIS
c(  "%","%", "%",   "pH","cmol(+)/kg",         "",    "g/cm3"),  # ISSR-800
)
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod")
df <- data.frame(voi.list.sg,
c("%%","%%","%%","pHx10","mmol(c)/kg",    "dg/kg",   "cg/cm3"),  #SG
c("%",  "%", "%",   "pH",          "", "log10(%)",    "g/cm3"),  # POLARIS
c("%%","%%","%%","pHx10","cmol(c)/kg",     "g/gF",    "Mg/m3"),  # GSM
c("%",  "%", "%",   "pH",          "",        "%",    "g/cm3"),  # SPCG100USA
c(  "%","%", "%","pHx10",          "",    "5g/Kg", "10 kg/m3"),  # LandGIS
c(  "%","%", "%",   "pH","cmol(+)/kg",         "",    "g/cm3")  # ISSR-800
)
names(df)
df <- data.frame(list=voi.list.sg,
sg=c("%%","%%","%%","pHx10","mmol(c)/kg",    "dg/kg",   "cg/cm3"),  #SG
p=c("%",  "%", "%",   "pH",          "", "log10(%)",    "g/cm3"),  # POLARIS
gsm=c("%%","%%","%%","pHx10","cmol(c)/kg",     "g/gF",    "Mg/m3"),  # GSM
spcg=c("%",  "%", "%",   "pH",          "",        "%",    "g/cm3"),  # SPCG100USA
lgis=c(  "%","%", "%","pHx10",          "",    "5g/Kg", "10 kg/m3"),  # LandGIS
issr=c(  "%","%", "%",   "pH","cmol(+)/kg",         "",    "g/cm3")  # ISSR-800
)
knitr::kable(
df, caption = 'Properties and units of measure',
col.names=c("Property","SoilGrids","POLARIS","GlobalSoilMap", "SPCG100USA", "LandGIS", "ISSR-800"),
booktabs = TRUE)
summary(r.p)
1/.58
