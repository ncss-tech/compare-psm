ss
deg
deg*a
1/60/60
a/60/60
a
a/(3600)
a*3600)
a*3600
setwd("~/GitHub/ncss-tech/compare-psm/scripts_compare")
terra::plot(regions.gsm.sg$map1["rih"], main = "Homogeneity -- SG250 vs. GSM")
terra::plot(regions.gsm.sg$map2["rih"], main = "Completeness -- SG250 vs. GSM")
n <- length(values.all) - sum(is.na(values.all))
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
fig.align = 'center', fig.path = './figs/cf_maps/')
knitr::opts_chunk$set(cache.extra = R.version.string)
# Chunk 2
library(raster, warn.conflicts=FALSE)      # previous version of raster classes now in `terra`
#   needed for landscape metrics
library(terra, warn.conflicts=FALSE)       # Robert Hijmans raster and vector data
library(rgdal)       # CRS
library(sp)          # `sp` spatial classes
library(sf)          # Simple Features
require(xtable)      # format tables for LaTeX
library(dplyr)       # data wrangling
library(ggplot2)     # ggplot graphics
library(gridExtra)
library(RColorBrewer)
library(sabre)       # compare polygon map spatial structure
library(landscapemetrics)   # FRAGSTATS metrics
library(landscapetools)
library(gstat)      # variogram modelling
# Chunk 3
base.dir <- "/Users/rossiter/ds/Compare_PSM/"
# Chunk 4: aoi
tile.lrc <- c(-77, 35)   # lower-right corner
tile.size <- 1
tile.ulc <- c(tile.lrc[1]-tile.size, tile.lrc[2]+tile.size) # upper-left corner
aoi <- paste0("lat", tile.lrc[2], tile.ulc[2],
"_lon", tile.ulc[1], tile.lrc[1])
# Chunk 5: voi
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.n <- 1
voi.sg <- voi.list.sg[voi.n]
# Chunk 6: depth
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.n <- 4
# Chunk 7: voi.depth.sg
voi.depth <- paste0(voi.sg, "_", depth.list.sg[depth.n])
# Chunk 8
(gsm <- rast(paste0(base.dir, aoi, "/gsm_tile_250_", voi.depth, ".tif")))
names(gsm) <- "voi"
(sg <- rast(paste0(base.dir, aoi, "/sg_tile_250_", voi.depth, ".tif")))
names(sg) <- "voi"
file.name <- paste0(base.dir, aoi, "/issr8_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (issr8 <- rast(file.name)); names(issr8) <- "voi" }
file.name <- paste0(base.dir, aoi, "/psu_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (psu <- rast(file.name)); names(psu) <- "voi" }
file.name <- paste0(base.dir, aoi, "/polaris_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (polaris <- rast(file.name)); names(polaris) <- "voi" }
file.name <- paste0(base.dir, aoi, "/landgis_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (landgis <- rast(file.name)); names(landgis) <- "voi" }
rgdal::showP4(crs(sg))
# Chunk 9: crop.test.area
test.tile.size <- 0.2  # degrees
test.tile.x.offset <- 0.2  # west from right edge
test.tile.y.offset <- 0.7  # north from bottom edge
(tmp <- as.vector(ext(sg)))
tmp["xmax"] <- tmp["xmax"] - test.tile.x.offset
tmp["xmin"] <- tmp["xmax"] - test.tile.size
tmp["ymin"] <- tmp["ymin"] + test.tile.y.offset
tmp["ymax"] <- tmp["ymin"] + test.tile.size
ext(tmp)
sg.crop <- crop(sg, ext(tmp))
gsm.crop <- crop(gsm, ext(tmp))
if (exists("issr8")) { issr8.crop <- crop(issr8, ext(tmp)) }
if (exists("psu")) { psu.crop <- crop(psu, ext(tmp)) }
if (exists("polaris")) { polaris.crop <- crop(polaris, ext(tmp)) }
if (exists("landgis")) { landgis.crop <- crop(landgis, ext(tmp)) }
# Chunk 10: zlim
zlim <- c(floor(min(values(sg.crop)*10,
values(gsm.crop)*10,
ifelse(exists("issr8.crop"), values(issr8.crop)*10, NA),
ifelse(exists("psu.crop"), values(psu.crop)*10, NA),
ifelse(exists("polaris.crop"), values(polaris.crop)*10, NA),
ifelse(exists("landgis.crop"), values(landgis.crop)*10, NA),
na.rm=TRUE)),
ceiling(max(values(sg.crop)*10,
values(gsm.crop)*10,
ifelse(exists("issr8.crop"), values(issr8.crop)*10,  NA),
ifelse(exists("psu.crop"), values(psu.crop)*10, NA),
ifelse(exists("polaris.crop"), values(polaris.crop)*10, NA),
ifelse(exists("landgis.crop"), values(landgis.crop)*10, NA),
na.rm=TRUE)))/10
print(zlim)
# Chunk 11: side.by.side
par(mfrow=c(3,2))
plot(gsm.crop, main="GSM v0.5", range=zlim)
plot(sg.crop, main="SoilGrids250", range=zlim)
if (exists("psu.crop")) plot(psu.crop, main="SPCG100USA", range=zlim)
if (exists("polaris.crop")) plot(polaris.crop, main="POLARIS", range=zlim)
if (exists("landgis.crop")) plot(landgis.crop, main="LandGIS", range=zlim)
if (exists("issr8.crop")) plot(issr8.crop, main="ISSR-800", range=zlim)
par(mfrow=c(1,1))
# Chunk 12
rmse <- function(v1, v2) {
round(sqrt(mean((v1-v2)^2, na.rm=TRUE)),3)
}
me <- function(v1, v2) {
round(mean(v1-v2, na.rm=TRUE), 3)
}
rmse.adj <- function(v1, v2) {   # RMSE adjusted for ME (bias)
me <- mean(v1-v2, na.rm=TRUE)
v2.adj <- v2 + me
round(sqrt(mean((v1-v2.adj)^2, na.rm=TRUE)),3)
}
# Chunk 13
stats.compare <- data.frame(PSM_product = "", MD = 0, RMSD = 0, RMSD.Adjusted = 0)
stats.compare[1, ] <- c("SoilGrids250",
me(values(gsm.crop),values(sg.crop)),
rmse(values(gsm.crop),values(sg.crop)),
rmse.adj(values(gsm.crop),values(sg.crop))
)
if (exists("psu.crop")) stats.compare[2, ] <- c("SPCG100USA",
me(values(gsm.crop),values(psu.crop)),
rmse(values(gsm.crop),values(psu.crop)),
rmse.adj(values(gsm.crop),values(psu.crop))
)
if (exists("polaris.crop")) stats.compare[3, ] <- c("POLARIS",
me(values(gsm.crop),values(polaris.crop)),
rmse(values(gsm.crop),values(polaris.crop)),
rmse.adj(values(gsm.crop),values(polaris.crop))
)
if (exists("landgis.crop")) stats.compare[4, ] <- c("POLARIS",
me(values(gsm.crop),values(landgis.crop)),
rmse(values(gsm.crop),values(landgis.crop)),
rmse.adj(values(gsm.crop),values(landgis.crop))
)
if (exists("issr8.crop")) stats.compare[5, ] <- c("POLARIS",
me(values(gsm.crop),values(issr8.crop)),
rmse(values(gsm.crop),values(issr8.crop)),
rmse.adj(values(gsm.crop),values(issr8.crop))
)
print(stats.compare)
# Chunk 14: side.by.side.unbiased
sg.adj <- sg.crop + me(values(gsm.crop),values(sg.crop))
if (exists("psu.crop")) psu.adj <- psu.crop + me(values(gsm.crop),values(psu.crop))
if (exists("polaris.crop")) polaris.adj <- polaris.crop + me(values(gsm.crop),values(polaris.crop))
if (exists("landgis.crop")) landgis.adj <- landgis.crop + me(values(gsm.crop),values(landgis.crop))
if (exists("issr8.crop")) issr8.adj <- issr8.crop + me(values(gsm.crop),values(issr8.crop))
# Chunk 15: zlim.adj
zlim.adj <- c(floor(min(values(sg.adj)*10,
values(gsm.crop)*10,
ifelse(exists("issr8.adj"), values(issr8.adj)*10, NA),
ifelse(exists("psu.adj"), values(psu.adj)*10, NA),
ifelse(exists("polaris.adj"), values(polaris.adj)*10, NA),
ifelse(exists("landgis.adj"), values(landgis.adj)*10, NA),
na.rm=TRUE)),
ceiling(max(values(sg.adj)*10,
values(gsm.crop)*10,
ifelse(exists("issr8.adj"), values(issr8.adj)*10,  NA),
ifelse(exists("psu.adj"), values(psu.adj)*10, NA),
ifelse(exists("polaris.adj"), values(polaris.adj)*10, NA),
ifelse(exists("landgis.adj"), values(landgis.adj)*10, NA),
na.rm=TRUE)))/10
print(zlim.adj)
# Chunk 16: reset.adj
# gsm was the basis
sg.adj <- sg.crop
if (exists("psu.crop")) psu.adj <- psu.crop
if (exists("polaris.crop")) polaris.adj <- polaris.crop
if (exists("landgis.crop")) landgis.adj <- landgis.crop
if (exists("issr8.crop")) issr8.adj <- issr8.crop
zlim.adj <- zlim
n.class <- 8
#
values.all <- c(values(gsm.crop),
values(sg.adj),
ifelse(exists("issr8.adj"), values(issr8.adj), NA),
ifelse(exists("psu.adj"), values(psu.adj), NA),
ifelse(exists("landgis.adj"), values(landgis.adj), NA),
ifelse(exists("polaris.adj"), values(polaris.adj), NA))
length(values.all)
summary(values.all)
values.all.sort <- sort(values.all)
#
n <- length(values.all) - sum(is.na(values.all))
(cut.positions <- round(n/n.class))
(cuts <- values.all.sort[cut.positions * 1:(n.class-1)])
hist(values.all, breaks=36, main="Histogram equalization")
abline(v=cuts, col="blue", lwd=2)
make.ground.overlay <- function(voi, depth, quantile, tile.lrc=c(-77, 41),
subtile.offset=c(0, 0), subtile.size=3) {
# import and local storage
base.dir <- "/Users/rossiter/ds/"
base.dir.polaris <- paste0(base.dir, "POLARIS")
base.dir.import <- "/Volumes/Pythagoras/ds/"
base.dir.polaris.import <- paste0(base.dir.import, "POLARIS")
# packages
library(terra)          # raster data, replaces `raster`
library(raster)         # some functions still not in `terra`
library(rgdal)          # GDAL access from R
library(gdalUtils)      # wrappers for GDAL utility programs that could be
#  called from the command line
library(sf)             # spatial data types
library(sp)             # older representation of spatial data types
library(maptools)       # create KML overlays, among others
# check arguments
if (length(tile.lrc) != 2)  {
print("Lower-right corner of tile must be two integers"); stop("Bad specification")
}
if (length(subtile.offset) != 2)  {
print("Lower-right corner of subtile offset must be two integers"); stop("Bad specification")
}
if ((subtile.size <= 0) || (subtile.size > 60)) {
print("Sub-tile size must be on the interval (0, 60]"); stop("Bad specification")
}
# check subtile is within tile
# ** TBC
voi.list <- c("alpha", "bd", "clay", "hb", "ksat", "lambda", "n", "om", "ph", "sand", "silt", "theta_r", "theta_s")
quantile.list <- c("p5", "p50", "p95", "mean")
depth.list <- c("0_5", "5_15", "15_30", "30_60", "60_100", "100_200")
if (!(voi %in% voi.list)) {
print(paste("No property", voi)); stop("Bad specification")
}
if (!(depth %in% depth.list)) {
print(paste("No depth slice", depth)); stop("Bad specification")
}
if (!(quantile %in% c("p5", "p50", "p95", "mean"))) {
print(paste("No quantile", quantile)); stop("Bad specification")
}
# setup
voi_layer <- paste(voi, paste0(depth,"cm"), quantile, sep="_")
# AOI
.tile.ulc <- c(tile.lrc[1]-1, tile.lrc[2]+1) # upper-left corner
.m <- matrix(c(.tile.ulc[1],tile.lrc[1],  #ulc
.tile.ulc[2], tile.lrc[2]  #lrc
), nrow=2)
bb.ll <- st_sfc(st_multipoint(.m))
st_crs(bb.ll) <- 4326
AOI.dir.prefix <- paste0("lat", tile.lrc[2], .tile.ulc[2],
"_lon", .tile.ulc[1], tile.lrc[1])
# import POLARIS tile
dest.dir.import <-  paste0(base.dir.polaris.import, "/",
AOI.dir.prefix, "/",
voi, "/",
quantile, "/",
depth)
if (!dir.exists(dest.dir.import)) {
dir.create(dest.dir.import, recursive = TRUE)
}
tile <- paste0("lat", tile.lrc[2], .tile.ulc[2],
"_lon", .tile.ulc[1], tile.lrc[1],
".tif")
dest.file <- paste0(dest.dir.import, "/", tile)
if (!file.exists(dest.file)) {
download.file(
url =
paste0("http://hydrology.cee.duke.edu/POLARIS/PROPERTIES/v1.0/",
voi, "/", quantile, "/", depth, "/",
tile),
destfile = dest.file,
method = "auto")
} else {
print("Local copy of file already exists")
}
## read tile into R
r.p <- terra::rast(dest.file)
## limit to sub-tile
subtile.size.dd <- subtile.size/60
.subtile.offset.long.dd <- subtile.offset[1]/60
.subtile.offset.lat.dd <- subtile.offset[2]/60
(.subtile.lrc <- c(tile.lrc[1] - .subtile.offset.long.dd,
tile.lrc[2] + .subtile.offset.lat.dd)) # lower-right corner
(.subtile.ulc <- c(.subtile.lrc[1]-subtile.size.dd, .subtile.lrc[2]+subtile.size.dd)) # upper-left corner
.m <- c(.subtile.ulc[1], .subtile.lrc[1],
.subtile.lrc[2], .subtile.ulc[2])
bb.sub <- ext(.m)
r.p.sub <- crop(r.p, bb.sub)
# destination directory
dest.dir <-  paste0(base.dir.polaris, "/",
AOI.dir.prefix, "/",
voi, "/",
quantile, "/",
depth)
if (!dir.exists(dest.dir)) {
dir.create(dest.dir, recursive = TRUE)
}
# build PNG
tmp <- raster::raster(r.p.sub)
r.sp <- as(tmp, "SpatialPixelsDataFrame")
fullgrid(r.sp) <- TRUE
# grid on which to make the PNG
GRD <- maptools::GE_SpatialGrid(r.sp, maxPixels=4800) # high resolution
# write the PNG
filename.png <- paste0(dest.dir,"/", voi_layer, '.png')
png(file=filename.png, width=GRD$width, height=GRD$height,
bg="transparent")
par(mar=c(0,0,0,0), xaxs="i", yaxs="i")
image(r.sp, xlim=GRD$xlim, ylim=GRD$ylim,
col=topo.colors(128),
setParUsrBB=TRUE)
dev.off()
# write the KML, referring to the PNG
filename.kml <- paste0(dest.dir,"/", voi_layer, '.kml')
maptools::kmlOverlay(GRD,
kmlfile = filename.kml,
imagefile = filename.png,
name=paste0("POLARIS", voi_layer)
)
}
make.ground.overlay("silt", "0_5", "mean", c(-76, 42), c(40, 25), 4)
# Chunk 1
base.dir <- "/Users/rossiter/ds/"
base.dir.gsm <- paste0(base.dir, "GSM_USA")
# Chunk 2
options("rgdal_show_exportToProj4_warnings"="none")
library(XML)            # various XML utilities
library(terra)          # raster data, replaces `raster`
library(raster)         # some functions still not in `terra`
library(rgdal)          # GDAL access from R
library(gdalUtils)      # wrappers for GDAL utility programs that could be
#  called from the command line
library(sf)             # spatial data types
library(sp)             # older representation of spatial data types
library(maptools)       # create KML overlays, among others
# Chunk 3: voi.list
voi.list.gsm <- c("claytotal_r_g_kg", "silttotal_r_g_kg", "sandtotal_r_g_kg",
"ph1to1h2o_r_ions_pHx10", "ecec_r_cmolc_kg", "soc_r_mr_g_gF",
"dbthirdbar_lt2mm_r_g_cm3", "gravel_r_vol_ratio_m3_m3")
# Chunk 4: voi
voi <- 2
(voi.name <- paste0("mu_", voi.list.gsm[voi], "_"))
# Chunk 5: depth.list
depth.list.gsm <- c("000_005", "005_015", "015_030", "030_060", "060_100", "100_200")
# Chunk 6: depth
depth <- 1
(voi.depth.name <- paste0(voi.name, depth.list.gsm[depth]))
# Chunk 7: tile.1
## Lower-right corner, in integer degrees
#
tile.lrc <- c(-76, 42) # lower-right corner
#
## Tile size, in integer degrees
#
size.long <- 1; size.lat <- 1
#
tile.ulc <- c(tile.lrc[1]-size.long, tile.lrc[2]+size.lat) # upper-left corner
# Chunk 8
AOI.dir.prefix <- paste0("lat", tile.lrc[2], .tile.ulc[2],
"_lon", .tile.ulc[1], tile.lrc[1])
# Chunk 9: get.tile
src.dir <-  paste0(base.dir.gsm, AOI.dir.prefix)
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
"_lon", tile.ulc[1], tile.lrc[1])
src.dir <-  paste0(base.dir.gsm, AOI.dir.prefix)
src.dir <-  paste0(base.dir.gsm, "/", AOI.dir.prefix)
paste0(src.dir, "/GSM_", voi.depth.name, ".tif")
r.gsm <- terra::rast(file=paste0(src.dir, "/GSM_", voi.depth.name, ".tif"))
r.gsm
plot(r.gsm)
?rast
r.gsm <- terra::rast(paste0(src.dir, "/GSM_", voi.depth.name, ".tif"))
plot(r.gsm)
st_crs(r.gsm)
print(r.gsm)
file.name <- paste0(src.dir, "/GSM_", voi.depth.name, ".tif")
paste("No file", file.name)
class(r.gsm)
tmp <- raster::raster(r.gsm)
class(tmp)
r.sp.84 <- as(tmp, "SpatialPixelsDataFrame")
class(r.sp.84)
spplot(r.sp.84, col.regions=heat.colors(256))
filename.png <- paste0(src.dir.gsm,"/", voi_layer, '.png')
# Chunk 1
base.dir <- "/Users/rossiter/ds/"
base.dir.gsm <- paste0(base.dir, "GSM_USA")
# Chunk 2
options("rgdal_show_exportToProj4_warnings"="none")
library(XML)            # various XML utilities
library(terra)          # raster data, replaces `raster`
library(raster)         # some functions still not in `terra`
library(rgdal)          # GDAL access from R
library(gdalUtils)      # wrappers for GDAL utility programs that could be
#  called from the command line
library(sf)             # spatial data types
library(sp)             # older representation of spatial data types
library(maptools)       # create KML overlays, among others
# Chunk 3: voi.list
voi.list.gsm <- c("claytotal_r_g_kg", "silttotal_r_g_kg", "sandtotal_r_g_kg",
"ph1to1h2o_r_ions_pHx10", "ecec_r_cmolc_kg", "soc_r_mr_g_gF",
"dbthirdbar_lt2mm_r_g_cm3", "gravel_r_vol_ratio_m3_m3")
# Chunk 4: voi
voi <- 2
(voi.name <- paste0("mu_", voi.list.gsm[voi], "_"))
# Chunk 5: depth.list
depth.list.gsm <- c("000_005", "005_015", "015_030", "030_060", "060_100", "100_200")
# Chunk 6: depth
depth <- 1
(voi.depth.name <- paste0(voi.name, depth.list.gsm[depth]))
# Chunk 7: tile.1
## Lower-right corner, in integer degrees
#
tile.lrc <- c(-76, 42) # lower-right corner
#
## Tile size, in integer degrees
#
size.long <- 1; size.lat <- 1
#
tile.ulc <- c(tile.lrc[1]-size.long, tile.lrc[2]+size.lat) # upper-left corner
# Chunk 8
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
"_lon", tile.ulc[1], tile.lrc[1])
# Chunk 9: get.tile
src.dir.gsm <-  paste0(base.dir.gsm, "/", AOI.dir.prefix)
# Chunk 10: get-sg
file.name <- paste0(src.dir.gsm, "/GSM_", voi.depth.name, ".tif")
if (file.exists(file.name)) {
r.gsm <- terra::rast(file.name)
plot(r.gsm)
} else (stop(paste("No file", file.name)))
# Chunk 11: create.spdf
class(r.gsm)
tmp <- raster::raster(r.gsm)
class(tmp)
r.sp.84 <- as(tmp, "SpatialPixelsDataFrame")
class(r.sp.84)
# spplot(r.sp.84, col.regions=heat.colors(256))
# Chunk 12
# default maxPixels=600, we want more detail
GRD <- maptools::GE_SpatialGrid(r.sp.84, maxPixels=4800)
str(GRD)
filename.png <- paste0(src.dir.gsm,"/", voi_layer, '.png')
src.dir.gsm
filename.png <- paste0(src.dir.gsm,"/", voi.depth.name, '.png')
(filename.png <- paste0(src.dir.gsm,"/", voi.depth.name, '.png'))
subtile.offset.long <- 0  # minutes offst from lrc, longitude
subtile.offset.lat <- 15   # minutes offst from lrc, latitude
subtile.size <- 30  # minutes in long and lat
.tile.ulc <- c(tile.lrc[1]-1, tile.lrc[2]+1) # upper-left corner
.m <- matrix(c(.tile.ulc[1],tile.lrc[1],  #ulc
.tile.ulc[2], tile.lrc[2]  #lrc
), nrow=2)
bb.ll <- st_sfc(st_multipoint(.m))
st_crs(bb.ll) <- 4326
subtile.size.dd <- subtile.size/60
.subtile.offset.long.dd <- subtile.offset.long/60
.subtile.offset.lat.dd <- subtile.offset.lat/60
(.subtile.lrc <- c(tile.lrc[1] - .subtile.offset.long.dd,
tile.lrc[2] + .subtile.offset.lat.dd)) # lower-right corner
(.subtile.ulc <- c(.subtile.lrc[1]-subtile.size.dd, .subtile.lrc[2]+subtile.size.dd)) # upper-left corner
.m <- c(.subtile.ulc[1], .subtile.lrc[1],
.subtile.lrc[2], .subtile.ulc[2])
bb.sub <- ext(.m)
subtile.offset.long <- 0  # minutes offset from lrc, longitude
subtile.offset.lat <- 15   # minutes offset from lrc, latitude
subtile.size <- 3  # tile size, minutes in long and lat
.tile.ulc <- c(tile.lrc[1]-1, tile.lrc[2]+1) # upper-left corner
.m <- matrix(c(.tile.ulc[1],tile.lrc[1],  #ulc
.tile.ulc[2], tile.lrc[2]  #lrc
), nrow=2)
bb.ll <- st_sfc(st_multipoint(.m))
st_crs(bb.ll) <- 4326
subtile.size.dd <- subtile.size/60
.subtile.offset.long.dd <- subtile.offset.long/60
.subtile.offset.lat.dd <- subtile.offset.lat/60
(.subtile.lrc <- c(tile.lrc[1] - .subtile.offset.long.dd,
tile.lrc[2] + .subtile.offset.lat.dd)) # lower-right corner
(.subtile.ulc <- c(.subtile.lrc[1]-subtile.size.dd, .subtile.lrc[2]+subtile.size.dd)) # upper-left corner
.m <- c(.subtile.ulc[1], .subtile.lrc[1],
.subtile.lrc[2], .subtile.ulc[2])
bb.sub <- ext(.m)
subtile.size.dd <- subtile.size/60
.subtile.offset.long.dd <- subtile.offset.long/60
.subtile.offset.lat.dd <- subtile.offset.lat/60
(.subtile.lrc <- c(tile.lrc[1] - .subtile.offset.long.dd,
tile.lrc[2] + .subtile.offset.lat.dd)) # lower-right corner
(.subtile.ulc <- c(.subtile.lrc[1]-subtile.size.dd, .subtile.lrc[2]+subtile.size.dd)) # upper-left corner
.m <- c(.subtile.ulc[1], .subtile.lrc[1],
.subtile.lrc[2], .subtile.ulc[2])
bb.sub <- ext(.m)
bb.sub
r.gsm <- crop(r.gsm, bb.sub)
plot(r.gsm, col=topo.colors(64))
(filename.png <- paste0(src.dir.gsm,"/", voi.depth.name, '.png'))
png(file=filename.png, width=GRD$width, height=GRD$height,
bg="transparent")
par(mar=c(0,0,0,0), xaxs="i", yaxs="i")
image(r.sp.84, xlim=GRD$xlim, ylim=GRD$ylim,
col=heat.colors(256, alpha=1),  # maximum colour resolution for PNG, opaque
setParUsrBB=TRUE)  # use our bounding box
dev.off()
(filename.kml <- paste0(src.dir.gsm,"/", voi.depth.name, '.kml'))
maptools::kmlOverlay(GRD,
kmlfile = filename.kml,
imagefile = filename.png,
name=paste0("GSM", voi.depth.name)
)
subtile.offset.long <- 45  # minutes offset from lrc, longitude
subtile.offset.lat <- 19   # minutes offset from lrc, latitude
subtile.size <- 3  # tile size, minutes in long and lat
subtile.size.dd <- subtile.size/60
.subtile.offset.long.dd <- subtile.offset.long/60
.subtile.offset.lat.dd <- subtile.offset.lat/60
(.subtile.lrc <- c(tile.lrc[1] - .subtile.offset.long.dd,
tile.lrc[2] + .subtile.offset.lat.dd)) # lower-right corner
(.subtile.ulc <- c(.subtile.lrc[1]-subtile.size.dd, .subtile.lrc[2]+subtile.size.dd)) # upper-left corner
.m <- c(.subtile.ulc[1], .subtile.lrc[1],
.subtile.lrc[2], .subtile.ulc[2])
.m
