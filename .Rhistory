voi.list.gsm <- c("claytotal_r_g_kg", "silttotal_r_g_kg", "sandtotal_r_g_kg",
"ph1to1h2o_r_ions_pHx10", "ecec_r_cmolc_kg", "soc_r_mr_g_gF",
"dbthirdbar_lt2mm_r_g_cm3", "gravel_r_vol_ratio_m3_m3")
# Chunk 12: voi
(voi.name <- paste0("mu_", voi.list.gsm[params$voi.n], "_"))
dim(db)
head(names(db))
db.attr <- dplyr::select(db, matches(c("mukeyint", voi.name)))
names(db.attr)
dim(db.attr)
# the 2nd attribute is typical of all depths
# set the NoData values
na.val <- ifelse(is.integer(db.attr[,2]), 2^16-1,
ifelse(is.double(db.attr[,2]), min(db.attr[,2]),NA))
db.attr <- db.attr %>%
na_if(., na.val)
# summary(db.attr)
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.list.gsm <- c("000_005", "005_015", "015_030", "030_060", "060_100", "100_200")
depth.gsm <- depth.list.gsm[params$depth.n]
(voi.depth.name <- paste0(voi.name, depth.list.gsm[depth.gsm]))
depth.gsm
depth.gsm <- depth.list.gsm[params$depth.n]
(voi.depth.name <- paste0(voi.name, depth.gsm))
tile.lrc <- c(params$lrc_long, params$lrc_lat) # lower-right corner
# Tile size, in integer degrees
size.long <- params$size; size.lat <- params$size
tile.ulc <- c(tile.lrc[1]-size.long, tile.lrc[2]+size.lat) # upper-left corner
m <- matrix(c(tile.ulc[1],tile.lrc[1],  #ulc
tile.ulc[2], tile.lrc[2]  #lrc
),
nrow=2)
bb.ll <- st_sfc(st_multipoint(m))
st_crs(bb.ll) <- 4326
grid.name <- paste0(base.dir.gsm05.import, "mukeyint_SaS_3as/mukeyint_SaS_3as.tif")
file.info(grid.name)[c("size", "mtime")]
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE,
message = FALSE,
warning = FALSE,
purl = FALSE,
fig.align = 'center')
knitr::opts_chunk$set(cache.extra = R.version.string)
# Chunk 2
options("rgdal_show_exportToProj4_warnings"="none")
library(zen4R)          # access Zenodo
library(sf)             # spatial data types
library(terra)          # raster data, replaces `raster`
# Chunk 3
base.dir <- "/Users/rossiter/ds/"
base.dir.landgis <- paste0(base.dir, "LandGIS")
base.dir.import <- "/Volumes/Pythagoras/ds/"
base.dir.landgis.import <- paste0(base.dir.import, "LandGIS")
# Chunk 4
voi.list.landgis <- c("clay.wfraction_usda.3a1a1a",
"silt.wfraction_usda.3a1a1a",
"sand.wfraction_usda.3a1a1a",
"ph.h2o_usda.4c1a2a",
"organic.carbon_usda.6a1c",
"bulkdens.fineearth_usda.4a1h",
"coarsefrag.vfraction_usda_3b1")
voi.list.landgis.code <- c(1476854, 2525675, 1476851,
1475459, 1475457, 1475970,
2525681)
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "soc",  "bdod", "cfvo")
# Chunk 5
voi.sg <- voi.list.sg[params$voi.n]
voi.landgis <- voi.list.landgis[params$voi.n]
voi.landgis.code <- voi.list.landgis.code[params$voi.n]
# Chunk 6
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.list.landgis <- c("0", "10", "30", "60", "100", "200")
depth.sg <- depth.list.sg[params$depth.n]
depth.sg <- depth.list.landgis[params$depth.n]
if (depth == 1) {
top <- 1; bottom <- 2; weights <- c(2/3, 1/3)
} else if (depth == 2) { # both the same
top <- bottom <- 2; weights <- c(1/2, 1/2)
} else if (depth == 3) {
top <- 2; bottom <-3; weights <- c(1/3, 2/3)
} else if (depth == 4) {
top <- 3; bottom <- 4; weights <- c(1/2, 1/2)
} else if (depth == 5) {
top <- 4; bottom <- 5; weights <- c(1/2, 1/2)
} else if (depth == 6) {
top <- 5; bottom <- 6; weights <- c(1/2, 1/2)
}
voi.issr8 <- voi.list.issr8[voi.n]
if (voi.issr8=="") { stop(paste0("No ISSR8 property #", voi.n)) }
voi.issr8 <- voi.list.issr8[voi.n]
if (voi.issr8=="") { stop(paste0("No ISSR8 property #", voi.n)) }
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.list.issr8 <- c("05", "025", "2550", "3060", "", "")
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.list.issr8 <- c("05", "025", "2550", "3060", "", "")
if (voi.issr8=="") { stop(paste0("No ISSR8 depth slice #", depth.n)) }
v.all <- data.frame(gsm=values(r.gsm.sg),
sg=values(r.sg),
polaris=ifelse(exists("r.p.sg"), values(r.p.sg), NA),
psu=ifelse(exists("r.psu.sg"), values(r.psu.sg), NA),
landgis=ifelse(exists("r.landgis.sg"), values(r.landgis.sg), NA),
issr8=ifelse(exists("r.issr8.sg"), values(r.issr8.sg), NA))
dim(v.all)
cor.all <- cor(v.all, use="pairwise.complete.obs")
cor.upper <- cor.all; cor.upper[lower.tri(cor.upper)] <- NA
print(round(cor.upper, 3))
r.sg
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE,
message = FALSE,
warning = FALSE,
purl=FALSE,
fig.align = 'center',
fig.path = './figs/compare_sg/')
knitr::opts_chunk$set(cache.extra = R.version.string)
# Chunk 2
library(rgdal)      # R interface to GDAL
library(terra)      # for raster maps
library(sf)         # Simple Features spatial data
# library(gridExtra)  # arrange multiple plots
library(knitr)      # for fancy tables
library(xtable)     # (same)
# Chunk 3: base.dir
base.dir <- "/Users/rossiter/ds/"
base.dir.sg <- paste0(base.dir, "SoilGrids250")
base.dir.gsm <- paste0(base.dir, "GSM_USA")
base.dir.issr8 <- paste0(base.dir, "ISSR8")
base.dir.polaris <- paste0(base.dir, "POLARIS")
base.dir.psu <- paste0(base.dir, "SPCG100USA")
base.dir.landgis <- paste0(base.dir, "LandGIS")
# Chunk 4: base.dir.import
base.dir.import <- "/Volumes/Pythagoras/ds/"
base.dir.polaris.import <- paste0(base.dir.import, "POLARIS")
# Chunk 5: base.dir.export
base.dir.export <- paste0(base.dir, "Compare_PSM")
# Chunk 6
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.list.gsm <- c("claytotal_r_g_kg", "silttotal_r_g_kg", "sandtotal_r_g_kg",
"ph1to1h2o_r_ions_pHx10", "ecec_r_cmolc_kg", "soc_r_mr_g_gF",
"dbthirdbar_lt2mm_r_g_cm3", "gravel_r_vol_ratio_m3_m3")
voi.list.issr8 <- c("clay", "silt","sand","ph", "cec", "", "", "")
voi.list.polaris <- c("clay", "silt", "sand", "ph", "", "om", "bd", "")
voi.list.psu <- c("clay", "", "sand", "ph_h2o", "", "soc", "bd", "")
voi.list.landgis <- c("clay.wfraction_usda.3a1a1a",
"silt.wfraction_usda.3a1a1a",
"sand.wfraction_usda.3a1a1a",
"ph.h2o_usda.4c1a2a",
"",
"organic.carbon_usda.6a1c",
"bulkdens.fineearth_usda.4a1h",
"coarsefrag.vfraction_usda_3b1")
# Chunk 7
voi.n <- params$voi.n   # variable of interest, SoilGrids name
voi.sg <- voi.list.sg[voi.n]
voi.issr8 <- voi.list.issr8[voi.n]
voi.polaris <- voi.list.polaris[voi.n]
voi.psu <- voi.list.psu[voi.n]
voi.gsm <- voi.list.gsm[voi.n]
# Chunk 8
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
# SPCGUSA100 predicts at points, these were averaged to GSM slices during import
# --- these have the SG names
# LandGIS predicts at points, these were averaged to GSM slices during import
# --- these have the SG names
depth.list.polaris <- gsub("-", "_", depth.list.sg)
depth.list.issr8 <- gsub("-", "", depth.list.sg)
depth.list.gsm <- c("000_005", "005_015", "015_030", "030_060", "060_100", "100_200")
# Chunk 9
depth <- params$depth.n
# Chunk 10: lrc
tile.lrc <- c(params$lrc_long, params$lrc_lat) # lower-right corner
tile.size <- params$size                # tile dimensions
# Chunk 11: ulc
tile.ulc <- c(tile.lrc[1]-tile.size, tile.lrc[2]+tile.size) # upper-left corner
# Chunk 12
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
"_lon", tile.ulc[1], tile.lrc[1])
# Chunk 13: bbox.4326
m <- matrix(c(tile.ulc[1],tile.lrc[1],  #ulc
tile.ulc[2], tile.lrc[2]), nrow=2) #lrc
bb.ll <- st_sfc(st_multipoint(m))
st_crs(bb.ll) <- 4326   # ESPG code for WGS84 long/lat
# Chunk 14: bbox.igh
# convert to Homolosine. Note epsg=152160 is not in PROJ4 database
crs.igh <- '+proj=igh +lat_0=0 +lon_0=0 +datum=WGS84 +units=m +no_defs'
(bb.igh <- st_transform(bb.ll, crs.igh))
(bb.igh <- st_coordinates(bb.igh)[,1:2])
(bb <- as.vector(t(bb.igh)))
# Chunk 15: bbox.aea
crs.aea <- "+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
(bb.aea <- st_transform(bb.ll, crs.aea))
# Chunk 16: get.tiles.sg
# SoilGrids250 -- only the mean prediction in this script
# Use the EPSG:4326 version
src.dir <-  paste0(base.dir.sg ,"/",
AOI.dir.prefix, "/",
voi.sg, "/mean/",
depth.list.sg[depth], "cm")
(voi.depth.name <- paste0(voi.sg, "_", depth.list.sg[depth], "cm_mean_4326"))
(file.name <- paste0(src.dir, "/", voi.depth.name, '.tif'))
if (file.exists(file.name)) {
r.sg <- terra::rast(file.name)
names(r.sg) <- "SoilGrids250"
print(r.sg)
} else { stop("No SoilGrids250 tile, stopping") }
# Chunk 17: get.tiles.gsm
# GSM
src.dir <-  paste0(base.dir.gsm ,"/", AOI.dir.prefix)
voi.depth.name <- paste0(voi.gsm, "_", depth.list.gsm[depth])
(file.name <- paste0(src.dir, "/GSM_mu_", voi.depth.name, ".tif"))
if (file.exists(file.name)) {
r.gsm <- terra::rast(file.name)
names(r.gsm) <- "GSMv0.5"
print(r.gsm)
} else { stop("No GSM v0.5 tile, stopping") }
# Chunk 18: get.tiles.psu
# SPCG100USA
src.dir <-  paste0(base.dir.psu ,"/", AOI.dir.prefix)
(file.name <- paste0(src.dir, "/", voi.psu, "_", depth.list.sg[depth], '.tif'))
if (file.exists(file.name)) {
r.psu <- terra::rast(file.name)
names(r.psu) <- "spcg100usa"
print(r.psu)
}
# Chunk 19: get.tiles.polaris
# POLARIS -- only the mean prediction in this script
(file.name <- paste0(base.dir.polaris.import, "/",
AOI.dir.prefix, "/",
voi.list.polaris[params$voi.n], "/mean/",
depth.list.polaris[depth], "/",
AOI.dir.prefix, ".tif"))
if (file.exists(file.name)) {
r.p <- terra::rast(file.name)
names(r.p) <- "polaris"
print(r.p)
}
# Chunk 20: get.tiles.landgis
# LandGIS -- only the mean prediction in this script
(file.name <- paste0(base.dir.landgis, "/",
AOI.dir.prefix, "/",
voi.list.landgis[voi.n], "_",
depth.list.sg[depth],
".tif"))
if (file.exists(file.name)) {
r.landgis <- terra::rast(file.name)
names(r.landgis) <- "landgis"
print(r.landgis)
}
# Chunk 21: get.tiles.issr8
(file.name <- paste0(base.dir.issr8, "/",
AOI.dir.prefix, "/",
voi.list.issr8[voi.n], "_",
depth.list.issr8[depth],
".tif"))
if (file.exists(file.name)) {
r.issr8 <- terra::rast(file.name)
names(r.issr8) <- "ISSR-800"
print(r.issr8)
}
# Chunk 22: show.conversions
df <- data.frame(property=voi.list.sg,
#"clay"  "silt"  "sand"  "phh2o" "cec"   "soc"   "bdod"  "cfvo"
gsm=c("%%","%%","%%","pHx10","cmol(c)/kg","g/gF","Mg/m3", "m3/m3"),  # GSM
sg=c("%%","%%","%%","pHx10","mmol(c)/kg","dg/kg","cg/cm3", "cm3/dm3"),  #SG
p=c("%","%", "%","pH","", "log10(%)", "g/cm3", ""),  # POLARIS
spcg=c("%","%","%","pHx10", "", "%","g/cm3", ""),  # SPCG100USA
lgis=c("%","%","%","pHx10","","5g/Kg","10 kg/m3", "%"),  # LandGIS
issr=c("%","%","%","pH","cmol(+)/kg","","g/cm3", "%")  # ISSR-800
)
knitr::kable(
df, caption = 'Properties and units of measure',
col.names=c("Property", "GlobalSoilMap","SoilGrids","POLARIS", "SPCG100USA", "LandGIS", "ISSR-800"),
booktabs = TRUE)
# Chunk 23: make.conversion.matrix
conversions <- data.frame(property=voi.list.sg,
# sg=c("%%","%%","%%","pHx10","mmol(c)/kg","dg/kg","cg/cm3", "cm3/dm3"), #SG
gsm=c(1, 1, 1, 1 , 10, 0.01, 0.01, 0.1),  # GSM
p=c(10,  10, 10,  10, NA, NA, 100, NA),  # POLARIS -- SOM is special case
spcg=c(10,  10, 10, 1, NA,  1,   100, NA),  # SPCG100USA
lgis=c(10,  10, 10, 1, NA, 20, 0.1, 0.1),  # LandGIS
issr=c(10,  10, 10,  10, 10, NA, 1, 0.1)  # ISSR-800
)
knitr::kable(
conversions, caption = 'Conversion factors, multiply by these to match SoilGrids250',
col.names=c("Property","GlobalSoilMap", "POLARIS", "SPCG100USA", "LandGIS", "ISSR-800"),
booktabs = TRUE)
# Chunk 24: convert
(factors <- conversions[match(voi.sg, conversions$property),])
# GSM
fact <- as.numeric(factors[2])
if (!is.na(fact) && (fact != 1)) { r.gsm <- r.gsm*fact }
# POLARIS
if (exists("r.p")) {
fact <- as.numeric(factors[3])
if (!is.na(fact) && (fact != 1)) { r.p <- r.p*fact }
}
# SPCG100USA
if (exists("r.psu")) {
fact <- as.numeric(factors[4])
if (!is.na(fact) && (fact != 1)) { r.psu <- r.psu*fact }
}
# LandGIS
if (exists("r.landgis")) {
fact <- as.numeric(factors[5])
if (!is.na(fact) && (fact != 1)) { r.landgis <- r.landgis*fact }
}
# ISSR-800
if (exists("r.issr8")) {
fact <- as.numeric(factors[6])
if (!is.na(fact) && (fact != 1)) { r.issr8 <- r.issr8*fact }
}
# Chunk 25: polaris.soc
if (exists("r.p") && (voi.sg=="soc")) {
r.p <- ((10^r.p)*0.58*1000)
}
# Chunk 26: crs.show.1
rgdal::showP4(crs(r.sg))
data.frame(sg=res(r.sg)[1],
polaris=ifelse(exists("r.p"), res(r.p)[1], ""),
gsm=res(r.gsm)[1],
landgis=ifelse(exists("r.landgis"), res(r.landgis)[1], ""))
# Chunk 27: crs.show.2
if (exists("r.psu")) rgdal::showP4(crs(r.psu))
if (exists("r.issr8")) rgdal::showP4(crs(r.issr8))
# Chunk 28: crs.resample
r.gsm.sg <- terra::resample(r.gsm, r.sg, method="cubic")
if (exists("r.p")) { r.p.sg <- terra::resample(r.p, r.sg, method="cubic") }
if (exists("r.psu")) { r.psu.sg <- terra::resample(r.psu, r.sg, method="cubic") }
# Chunk 29: crs.project
if (exists("r.landgis")) {
r.landgis.sg <- terra::project(r.landgis, r.sg, method="cubic")
}
if (exists("r.issr8")) {
r.issr8.sg <- terra::project(r.issr8, r.sg, method="cubic")
}
# Chunk 30: mask.lakes
r.gsm.sg <- mask(r.gsm.sg, r.sg)
if (exists("r.p.sg")) { r.p.sg <- mask(r.p.sg, r.sg) }
if (exists("r.issr8.sg")) { r.issr8.sg <- mask(r.issr8.sg, r.sg) }
if (exists("r.psu.sg")) { r.psu.sg <- mask(r.psu.sg, r.sg) }
if (exists("r.landgis.sg")) { r.landgis.sg <- mask(r.landgis.sg, r.sg) }
# Chunk 31
r.sg <- mask(r.sg, r.gsm.sg)
if (exists("r.issr8.sg")) { r.issr8.sg <- mask(r.issr8.sg, r.gsm.sg) }
if (exists("r.psu.sg")) { r.psu.sg <- mask(r.psu.sg, r.gsm.sg) }
if (exists("r.landgis.sg")) { r.landgis.sg <- mask(r.landgis.sg, r.gsm.sg) }
# Chunk 32: plot.resampled
par(mfrow=c(2, 3))
r.sg
plot(r.gsm.sg, main="GSM v0.5")
plot(r.sg, main="SoilGrids250")
if (exists("r.p.sg")) { plot(r.p.sg, main="POLARIS") }
if (exists("r.psu.sg")) { plot(r.psu.sg, main="SPCG100USA") }
if (exists("r.landgis.sg")) { plot(r.landgis.sg, main="LandGIS") }
if (exists("r.issr8.sg")) { plot(r.issr8.sg, main="ISSR-800") }
par(mfrow=c(1, 1))
# Chunk 33: compare.zlim
zlim <- c(min(values(r.sg)*10, na.rm = TRUE),
max(values(r.sg)*10, na.rm = TRUE))/10
zlim <- c(floor(min(zlim[1]*10, values(r.gsm.sg)*10, na.rm=TRUE)),
ceiling(max(zlim[2]*10, values(r.gsm.sg)*10, na.rm=TRUE)))/10
if (exists("r.p.sg")) {
zlim <- c(floor(min(zlim[1]*10, values(r.p.sg)*10, na.rm=TRUE)),
ceiling(max(zlim[2]*10, values(r.p.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.psu.sg")) {
zlim <- c(floor(min(zlim[1]*10, values(r.psu.sg)*10, na.rm=TRUE)),
ceiling(max(zlim[2]*10, values(r.psu.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.landgis.sg")) {
zlim <- c(floor(min(zlim[1]*10, values(r.landgis.sg)*10, na.rm=TRUE)),
ceiling(max(zlim[2]*10, values(r.landgis.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.issr8.sg")) {
zlim <- c(floor(min(zlim[1]*10, values(r.issr8.sg)*10, na.rm=TRUE)),
ceiling(max(zlim[2]*10, values(r.issr8.sg)*10, na.rm=TRUE)))/10
}
# Chunk 34: hist.densities
max.dens <- function(r.map) {  # argument: the raster map
h <- hist(r.map,  breaks=24, plot = FALSE)
max(h$counts/(diff(h$breaks[1:2]))/sum(h$counts))
}
yl <- max(max.dens(r.gsm.sg), max.dens(r.sg))
if (exists("r.p.sg")) { yl <- max(yl, max.dens(r.p.sg))}
if (exists("r.psu.sg")) { yl <- max(yl, max.dens(r.psu.sg))}
if (exists("r.landgis.sg")) { yl <- max(yl, max.dens(r.landgis.sg))}
if (exists("r.issr8.sg")) { yl <- max(yl, max.dens(r.issr8.sg))}
# Chunk 35: hist.sg.props
yl <- c(0, yl) # standardize the density axis
par(mfrow=c(2,3))
hist(r.gsm.sg, breaks=24, main="GSM v0.5",
xlim=zlim, xlab="", freq = FALSE, ylim=yl)
hist(r.sg, breaks=24, main="SoilGrids250",
xlim=zlim, xlab="", freq = FALSE, ylim=yl)
if (exists("r.p.sg")) {
hist(r.p.sg, breaks=24, main="POLARIS",
xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
if (exists("r.psu.sg")) {
hist(r.psu.sg, breaks=24, main="SPCG100",
xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
if (exists("r.landgis.sg")) {
hist(r.landgis.sg, breaks=24, main="LandGIS",
xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
if (exists("r.issr8.sg")) {
hist(r.issr8.sg, breaks=24, main="ISSR-800",
xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
par(mfrow=c(1,1))
# Chunk 36: map.sg.props
par(mfrow=c(2,3))
terra::plot(r.gsm.sg, main="GSM v0.5", range=zlim)
terra::plot(r.sg, main="SoilGrids", range=zlim)
if (exists("r.p.sg")) {
terra::plot(r.p.sg, main="POLARIS", range=zlim)
}
if (exists("r.psu.sg")) {
terra::plot(r.psu.sg, main="SPCG100", range=zlim)
}
if (exists("r.landgis.sg")) {
terra::plot(r.landgis.sg, range=zlim, main="LandGIS")
}
if (exists("r.issr8.sg")) {
terra::plot(r.issr8.sg, range=zlim, main="ISSR-800")
}
par(mfrow=c(1,1))
v.all <- data.frame(gsm=values(r.gsm.sg),
sg=values(r.sg),
polaris=ifelse(exists("r.p.sg"), values(r.p.sg), NA),
psu=ifelse(exists("r.psu.sg"), values(r.psu.sg), NA),
landgis=ifelse(exists("r.landgis.sg"), values(r.landgis.sg), NA),
issr8=ifelse(exists("r.issr8.sg"), values(r.issr8.sg), NA))
dim(v.all)
summary(v.all)
exists("r.p.sg")
x <- ifelse(exists("r.p.sg"), values(r.p.sg), NA)
x
?ifelse
if (exists("r.p.sg")) {v.all$polaris <- values(r.p.sg) }
summary(v.all)
v.all <- data.frame(gsm=values(r.gsm.sg),
sg=values(r.sg),
polaris= NA,
psu=ifelse(exists("r.psu.sg"), values(r.psu.sg), NA),
landgis=ifelse(exists("r.landgis.sg"), values(r.landgis.sg), NA),
issr8=ifelse(exists("r.issr8.sg"), values(r.issr8.sg), NA))
if (exists("r.p.sg")) {v.all$polaris <- values(r.p.sg) }
summary(v.all)
v.all <- data.frame(gsm=values(r.gsm.sg),
sg=values(r.sg),
polaris=NA,
psu=NA,
landgis=NA,
issr8=NA)
if (exists("r.p.sg")) { v.all$polaris <- values(r.p.sg) }
if (exists("r.psu.sg")) { v.all$psu <- values(r.psu.sg) }
if (exists("r.landgis.sg")) { v.all$landgis <-  values(r.landgis.sg) }
if (exists("r.issr8.sg")) { v.all$issr8 <- values(r.issr8.sg) }
summary(v.all)
cor.all <- cor(v.all, use="pairwise.complete.obs")
cor.upper <- cor.all; cor.upper[lower.tri(cor.upper)] <- NA
print(round(cor.upper, 3))
params
print(paste0("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat))
print(paste0("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat, "; size:", params$size))
print(paste("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat, "; size:", params$size))
print(paste("voi.n:", params$voi.n, "; depth.n:", params$depth.n))
print(paste("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat, "; size:", params$size))
print(paste("voi.n:", params$voi.n, "; depth.n:", params$depth.n))
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, purl = FALSE,
fig.align = 'center', fig.path = './figs/compare_maps/')
knitr::opts_chunk$set(cache.extra = R.version.string)
# Chunk 2
library(raster, warn.conflicts=FALSE)      # previous version of raster classes now in `terra`
#   needed for landscape metrics
library(terra, warn.conflicts=FALSE)       # Robert Hijmans raster and vector data
library(rgdal)       # CRS
library(sp)          # `sp` spatial classes
library(sf)          # Simple Features
require(xtable)      # format tables for LaTeX
library(dplyr)       # data wrangling
library(ggplot2)     # ggplot graphics
library(gridExtra)
library(RColorBrewer)
library(sabre)       # compare polygon map spatial structure
library(landscapemetrics)   # FRAGSTATS metrics
library(landscapetools)
library(gstat)      # variogram modelling
# Chunk 3
base.dir <- "/Users/rossiter/ds/Compare_PSM/"
# Chunk 4
print(paste("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat, "; size:", params$size))
print(paste("voi.n:", params$voi.n, "; depth.n:", params$depth.n))
# Chunk 5: lrc
tile.lrc <- c(params$lrc_long, params$lrc_lat) # lower-right corner
tile.size <- params$size                # tile dimensions
# Chunk 6: ulc
tile.ulc <- c(tile.lrc[1]-tile.size, tile.lrc[2]+tile.size) # upper-left corner
# Chunk 7: aoi
aoi <- paste0("lat", tile.lrc[2], tile.ulc[2],
"_lon", tile.ulc[1], tile.lrc[1])
# Chunk 8: voi
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.sg <- voi.list.sg[params$voi.n]
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
voi.depth <- paste0(voi.sg, "_", depth.list.sg[parms$depth.n])
voi.depth <- paste0(voi.sg, "_", depth.list.sg[params$depth.n])
print(paste("quantiles.n:", params$quantiles.n))
print(paste("quantile.n:", params$quantile.n))
