---
title: "Comparing PSM products at regional resolution"
author:
- D G Rossiter
- d.g.rossiter@cornell.edu
date: "`r format(Sys.Date(), '%d-%B-%Y')`"
output:
  html_document:
    fig_align: center
    fig_height: 6
    fig_width: 6
    number_section: yes
    theme: spacelab
    df_print: paged
    toc: yes
    toc_float: yes
  word_document:
    toc: yes
---

```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      purl=FALSE,
                      fig.align = 'center',
                      fig.path = './figs/compare_sg/')
knitr::opts_chunk$set(cache.extra = R.version.string)
```

# Introduction

This script compares PSM products at 250 m grid resolution, which is used by SoilGrids250.
We consider this an appropriate resolution for regional studies.

Depending on the [property of interest](#voi), the following can be compared:

* [SoiLGrids250](https://www.isric.org/explore/soilgrids)  from ISRIC further abbreviated as _SG2_;
* [Global Soil Map v0.5 for the USA](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/research/?cid=nrcseprd1321715), further abbreviated as _GSMv05_;
* [Intermediate-scale gridded soil property and interpretation maps from averaged and aggregated SSURGO and STATSGO data](https://github.com/ncss-tech/ISSR-800), further abbreviated as _ISSR-800_;
* POLARIS Soil Properties;
* [Soil Properties and Class 100m Grids USA](https://doi.org/10.18113/S1KW2H), further abbreviated as _SPCG100USA_;
* [LandGIS](https://opengeohub.org/about-landgis) from the private company [EnvirometriX](http://envirometrix.nl/).

The PSM products must have been previously imported and restricted to the same area of interest (AOI), typically $1 \times 1^\circ$, to the locations indicated in the directory list.

We use GSM v0.5 as the reference map, since it is based directly on field survey (SSURGO and STATSGO). So this script requires, at a minimum, SoilGrids250 and GSM v0.5 products to have been imported.

This script must follow the import of the various products; these are in directory `../scripts_importmaps`.

To use this script:

1. Ajust the [directory structure](#dirs) to your system

2. [Select a property](#voi) and [select a depth slice](#depth).

3. [Select an Area of Interest](#aoi).

4. Either compile to HTML or PDF ("knit"), or "Run All" within R Markdown.

5. Generated figures will be in directory `./figs/compare_sg/`. These will be specific to the AOI, property and depth slice. So to save them from over-writing by other runs, move them to another directory.

6. Generated tables in \LaTeX format will be in directory `../LaTeX_tables`. The table names include AOI, property and depth slice and so are not over-written.

7. Generated harmonized maps will be [saved](#save) to directory `Compare_PSM` under the base directory, in a subdirectory named for the AOI. The file name includes the PSM method, property and depth slice.


# Setup

## Packages

```{r}
library(rgdal)      # R interface to GDAL
library(terra)      # for raster maps
library(sf)         # Simple Features spatial data
# library(gridExtra)  # arrange multiple plots
library(knitr)      # for fancy tables
library(xtable)     # (same)
```

## Base directory paths {#dirs}

Set base directories, specific to the local file system. 

1. `base.dir`: This is the location of the PSM tiles that have been cropped to an AOI by an import script.

```{r base.dir}
base.dir <- "/Users/rossiter/ds/"
base.dir.sg <- paste0(base.dir, "SoilGrids250")
base.dir.gsm <- paste0(base.dir, "GSM_USA")
base.dir.issr8 <- paste0(base.dir, "ISSR8")
base.dir.polaris <- paste0(base.dir, "POLARIS")
base.dir.psu <- paste0(base.dir, "SPCG100USA")
base.dir.landgis <- paste0(base.dir, "LandGIS")
```

2. `base.dir.import`: This is where downloaded large GeoTIFF are located. Because of their size they may be on a separate file system, e.g., removable or networked drive. Files may have been downloaded here by an import script, or by direct download from the data provider.

In this script this location is only used for POLARIS, since they are imported directly as $1 \times 1^\circ$ tiles by script `./scripts_importmaps/POLARIS_import.Rmd`.

```{r base.dir.import}
base.dir.import <- "/Volumes/Pythagoras/ds/"
base.dir.polaris.import <- paste0(base.dir.import, "POLARIS")
```

3. `base.dir.export`: This is where generated harmonized maps will be saved for further processing, e.g., comparing patterns.

```{r base.dir.export}
base.dir.export <- paste0(base.dir, "Compare_PSM")
```

# Property of interest {#voi}

Property names in various systems. Note that all except GSM v0.5 and SoilGrids250 are missing one or more properties. Such products will be omitted from comparisons for those properties.

Properties that be compared are: clay, silt, sand weight concentrations; pH in 1:1 water; CEC; SOC; bulk density of the fine earth; coarse fragment volume proportion. See the import script for each product for a link to a description of the properties and their units of measure.

```{r}
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.list.gsm <- c("claytotal_r_g_kg", "silttotal_r_g_kg", "sandtotal_r_g_kg", 
                  "ph1to1h2o_r_ions_pHx10", "ecec_r_cmolc_kg", "soc_r_mr_g_gF",
                  "dbthirdbar_lt2mm_r_g_cm3", "gravel_r_vol_ratio_m3_m3")
voi.list.issr8 <- c("clay", "silt","sand","ph", "cec", "", "", "")
voi.list.polaris <- c("clay", "silt", "sand", "ph", "", "om", "bd", "") 
voi.list.psu <- c("clay", "", "sand", "ph_h2o", "", "soc", "bd", "")
voi.list.landgis <- c("clay.wfraction_usda.3a1a1a",
                      "silt.wfraction_usda.3a1a1a",
                      "sand.wfraction_usda.3a1a1a",
                      "ph.h2o_usda.4c1a2a",
                      "",
                      "organic.carbon_usda.6a1c",
                      "bulkdens.fineearth_usda.4a1h",
                      "coarsefrag.vfraction_usda_3b1")
```

Select the position in these lists

```{r}
voi <- 1
voi.sg <- voi.list.sg[voi]
voi.issr8 <- voi.list.issr8[voi]
voi.polaris <- voi.list.polaris[voi]
voi.psu <- voi.list.psu[voi]
voi.gsm <- voi.list.gsm[voi]
```

# Depth of interest {#depth}

Depth slices:

```{r}
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
# SPCGUSA100 predicts at points, these were averaged to GSM slices during import
# --- these have the SG names
# LandGIS predicts at points, these were averaged to GSM slices during import
# --- these have the SG names
depth.list.polaris <- gsub("-", "_", depth.list.sg)
depth.list.issr8 <- gsub("-", "", depth.list.sg)
depth.list.gsm <- c("000_005", "005_015", "015_030", "030_060", "060_100", "100_200")
```

Select the depth slice:

```{r}
depth <- 1
```


# Area of Interest (AOI) {#aoi}

We use a $1 \times 1^\circ$ tile, because that is how POLARIS data is served.
Specify the lower-right corner, then compute the upper-right corner 1 degree west and north.

Specify the two corners using WGS84 geographic coordinates:

Specify the lower-right corner:

```{r lrc}
tile.lrc <- c(-77, 35)   # lower-right corner
tile.size <- 1
```

Compute the upper-left coner:

```{r ulc}
tile.ulc <- c(tile.lrc[1]-tile.size, tile.lrc[2]+tile.size) # upper-left corner
```

A prefix for directories and file names, to keep AOI results separate.

```{r}
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
                         "_lon", tile.ulc[1], tile.lrc[1])
```



Bounding box:

```{r bbox.4326}
m <- matrix(c(tile.ulc[1],tile.lrc[1],  #ulc
              tile.ulc[2], tile.lrc[2]), nrow=2) #lrc
bb.ll <- st_sfc(st_multipoint(m))
st_crs(bb.ll) <- 4326   # ESPG code for WGS84 long/lat
```

Project the bounding box to Goode Interrupted Homolosine (IGH) used by SoilGrids:

```{r bbox.igh}
# convert to Homolosine. Note epsg=152160 is not in PROJ4 database
crs.igh <- '+proj=igh +lat_0=0 +lon_0=0 +datum=WGS84 +units=m +no_defs'
(bb.igh <- st_transform(bb.ll, crs.igh))
(bb.igh <- st_coordinates(bb.igh)[,1:2])
(bb <- as.vector(t(bb.igh)))
```

Project the bounding box to the AEA. This is the CRS used by ISSR-800 and SPCG100USA:

```{r bbox.aea}
crs.aea <- "+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
(bb.aea <- st_transform(bb.ll, crs.aea))
```

# Products to compare

Load the tiles in their native CRS, as processed in the import scripts.

## SoilGrids250

This is required; all the properties to compare are mapped by SoilGrids250.

```{r get.tiles.sg}
# SoilGrids250 -- only the mean prediction in this script
# Use the EPSG:4326 version
src.dir <-  paste0(base.dir.sg ,"/", 
                   AOI.dir.prefix, "/", 
                   voi.sg, "/mean/",
                   depth.list.sg[depth], "cm")
(voi.depth.name <- paste0(voi.sg, "_", depth.list.sg[depth], "cm_mean_4326"))
(file.name <- paste0(src.dir, "/", voi.depth.name, '.tif'))
if (file.exists(file.name)) {
  r.sg <- terra::rast(file.name)
  names(r.sg) <- "SoilGrids250"
  print(r.sg)
} else { stop("No SoilGrids250 tile, stopping") }
```

## GSM

```{r get.tiles.gsm}
# GSM
src.dir <-  paste0(base.dir.gsm ,"/", AOI.dir.prefix)
voi.depth.name <- paste0(voi.gsm, "_", depth.list.gsm[depth])
(file.name <- paste0(src.dir, "/GSM_mu_", voi.depth.name, ".tif"))
if (file.exists(file.name)) {
  r.gsm <- terra::rast(file.name)
  names(r.gsm) <- "GSMv0.5"
  print(r.gsm)
} else { stop("No GSM v0.5 tile, stopping") }
```


## SPCG100USA

```{r get.tiles.psu}
# SPCG100USA
src.dir <-  paste0(base.dir.psu ,"/", AOI.dir.prefix)
(file.name <- paste0(src.dir, "/", voi.psu, "_", depth.list.sg[depth], '.tif'))
if (file.exists(file.name)) {
  r.psu <- terra::rast(file.name)
  names(r.psu) <- "spcg100usa"
  print(r.psu)
}
```

## POLARIS

```{r get.tiles.polaris}
# POLARIS -- only the mean prediction in this script
(file.name <- paste0(base.dir.polaris.import, "/",
                     AOI.dir.prefix, "/",
                     voi.list.polaris[voi], "/mean/",
                     depth.list.polaris[depth], "/",
                     AOI.dir.prefix, ".tif"))
if (file.exists(file.name)) {
  r.p <- terra::rast(file.name)
  names(r.p) <- "polaris"
  print(r.p)
}
```

## LandGIS

```{r get.tiles.landgis}
# LandGIS -- only the mean prediction in this script
(file.name <- paste0(base.dir.landgis, "/",
                     AOI.dir.prefix, "/",
                     voi.list.landgis[voi], "_",
                     depth.list.sg[depth],
                     ".tif"))
if (file.exists(file.name)) {
  r.landgis <- terra::rast(file.name)
  names(r.landgis) <- "landgis"
  print(r.landgis)
}
```

## ISSR-800


```{r get.tiles.issr8}
(file.name <- paste0(base.dir.issr8, "/",
                     AOI.dir.prefix, "/",
                     voi.list.issr8[voi], "_",
                     depth.list.issr8[depth],
                     ".tif"))
if (file.exists(file.name)) {
  r.issr8 <- terra::rast(file.name)
  names(r.issr8) <- "ISSR-800"
  print(r.issr8)
}
```

# Make the units compatible

Depending on the property, data in some coverages need to be converted to the units used in SoilGrids250; we choose this as the base; note these are integers. Here are the units:

```{r show.conversions}
df <- data.frame(property=voi.list.sg, 
                 #"clay"  "silt"  "sand"  "phh2o" "cec"   "soc"   "bdod"  "cfvo" 
                 gsm=c("%%","%%","%%","pHx10","cmol(c)/kg","g/gF","Mg/m3", "m3/m3"),  # GSM
                 sg=c("%%","%%","%%","pHx10","mmol(c)/kg","dg/kg","cg/cm3", "cm3/dm3"),  #SG
                 p=c("%","%", "%","pH","", "log10(%)", "g/cm3", ""),  # POLARIS
                 spcg=c("%","%","%","pHx10", "", "%","g/cm3", ""),  # SPCG100USA
                 lgis=c("%","%","%","pHx10","","5g/Kg","10 kg/m3", "%"),  # LandGIS
                 issr=c("%","%","%","pH","cmol(+)/kg","","g/cm3", "%")  # ISSR-800
                 )
knitr::kable(
  df, caption = 'Properties and units of measure',
  col.names=c("Property", "GlobalSoilMap","SoilGrids","POLARIS", "SPCG100USA", "LandGIS", "ISSR-800"),
  booktabs = TRUE)
```  

Make a matrix with the conversions to SoilGrids250 units. These factors *multiply* the source, to match SoilGrids250. `NA` values indicate that the property is not included in the source.

Some conversions are given [here](https://www.isric.org/explore/soilgrids/faq-soilgrids#What_do_the_filename_codes_mean).

```{r make.conversion.matrix}
conversions <- data.frame(property=voi.list.sg, 
                 # sg=c("%%","%%","%%","pHx10","mmol(c)/kg","dg/kg","cg/cm3", "cm3/dm3"), #SG
                 gsm=c(1, 1, 1, 1 , 10, 0.01, 0.01, 0.1),  # GSM
                 p=c(10,  10, 10,  10, NA, NA, 100, NA),  # POLARIS -- SOM is special case
                 spcg=c(10,  10, 10, 1, NA,  1,   100, NA),  # SPCG100USA
                 lgis=c(10,  10, 10, 1, NA, 20, 0.1, 0.1),  # LandGIS
                 issr=c(10,  10, 10,  10, 10, NA, 1, 0.1)  # ISSR-800
                 )
knitr::kable(
  conversions, caption = 'Conversion factors, multiply by these to match SoilGrids250',
  col.names=c("Property","GlobalSoilMap", "POLARIS", "SPCG100USA", "LandGIS", "ISSR-800"),
  booktabs = TRUE)
```

Convert units as necessary:

```{r convert}
(factors <- conversions[match(voi.sg, conversions$property),])
# GSM
fact <- as.numeric(factors[2])
if (!is.na(fact) && (fact != 1)) { r.gsm <- r.gsm*fact }
# POLARIS
if (exists("r.p")) {
  fact <- as.numeric(factors[3])
  if (!is.na(fact) && (fact != 1)) { r.p <- r.p*fact }
}
# SPCG100USA
if (exists("r.psu")) {
  fact <- as.numeric(factors[4])
  if (!is.na(fact) && (fact != 1)) { r.psu <- r.psu*fact }
}
# LandGIS
if (exists("r.landgis")) {
  fact <- as.numeric(factors[5])
  if (!is.na(fact) && (fact != 1)) { r.landgis <- r.landgis*fact }
}
# ISSR-800
if (exists("r.issr8")) {
  fact <- as.numeric(factors[6])
  if (!is.na(fact) && (fact != 1)) { r.issr8 <- r.issr8*fact }
}
```

Note that SOC for POLARIS is a special case, because of the log10-scale, and because it is SOM, not SOC. Use the conventional conversion factor 0.58 = 1/1.724138.

```{r polaris.soc}
if (exists("r.p") && (voi.sg=="soc")) {
    r.p <- ((10^r.p)*0.58*1000) 
}
```

# Match resolution and CRS

SoilGrids250, GSM v0.5, POLARIS and LandGIS are in EPSG:4326 (WGS84 long/lat), at different grid resolutions.

```{r crs.show.1}
rgdal::showP4(crs(r.sg))
data.frame(sg=res(r.sg)[1], 
           polaris=ifelse(exists("r.p"), res(r.p)[1], ""),
           gsm=res(r.gsm)[1],
           landgis=ifelse(exists("r.landgis"), res(r.landgis)[1], ""))
```

ISSR-800 and SPCG100USA are in a CONUS Albers Equal Area, but with slightly different definitions of the datums, also with different resolutions (800 and 100 m, respectively). The GRS80 ellipsoid is the basis of the NAD83 datum, and centred with WGS84, so there effectively no difference.

```{r crs.show.2}
if (exists("r.psu")) rgdal::showP4(crs(r.psu))
if (exists("r.issr8")) rgdal::showP4(crs(r.issr8))
```

Resample products into SoilGrids250 WGS84 250m nominal pixels, using cubic interpolation.

```{r crs.resample}
r.gsm.sg <- terra::resample(r.gsm, r.sg, method="cubic")
if (exists("r.p")) { r.p.sg <- terra::resample(r.p, r.sg, method="cubic") }
if (exists("r.psu")) { r.psu.sg <- terra::resample(r.psu, r.sg, method="cubic") }
```

For LandGIS and ISSR-800 the CRS must be changed, not just the resolution:

```{r crs.project}
if (exists("r.landgis")) { 
  r.landgis.sg <- terra::project(r.landgis, r.sg, method="cubic") 
  }
if (exists("r.issr8")) { 
  r.issr8.sg <- terra::project(r.issr8, r.sg, method="cubic") 
  }
```


# Make all maps cover the same area

POLARIS predicts in the lakes, the USA products predict in built-up areas. Mask these out with SoilGrids250, which does not.

```{r mask.lakes}
r.gsm.sg <- mask(r.gsm.sg, r.sg)
if (exists("r.p.sg")) { r.p.sg <- mask(r.p.sg, r.sg) }
if (exists("r.issr8.sg")) { r.issr8.sg <- mask(r.issr8.sg, r.sg) }
if (exists("r.psu.sg")) { r.psu.sg <- mask(r.psu.sg, r.sg) }
if (exists("r.landgis.sg")) { r.landgis.sg <- mask(r.landgis.sg, r.sg) }
```

Then mask from GSM v0.5 to get consistent coverage, because it is the true 1 degree tile. SoilGrids is larger and so are the two originally in AEA projection.

```{r}
r.sg <- mask(r.sg, r.gsm.sg)
if (exists("r.issr8.sg")) { r.issr8.sg <- mask(r.issr8.sg, r.gsm.sg) }
if (exists("r.psu.sg")) { r.psu.sg <- mask(r.psu.sg, r.gsm.sg) }
if (exists("r.landgis.sg")) { r.landgis.sg <- mask(r.landgis.sg, r.gsm.sg) }
```

Check that the maps cover the same area, ignore different stretches for now:

```{r plot.resampled, fig.width=12, fig.height=8}
par(mfrow=c(2, 3))
r.sg
plot(r.gsm.sg, main="GSM v0.5")
plot(r.sg, main="SoilGrids250")
if (exists("r.p.sg")) { plot(r.p.sg, main="POLARIS") }
if (exists("r.psu.sg")) { plot(r.psu.sg, main="SPCG100USA") }
if (exists("r.landgis.sg")) { plot(r.landgis.sg, main="LandGIS") }
if (exists("r.issr8.sg")) { plot(r.issr8.sg, main="ISSR-800") }
par(mfrow=c(1, 1))
```


# Compare

## Compute common range for all products

```{r compare.zlim}
zlim <- c(min(values(r.sg)*10, na.rm = TRUE),
          max(values(r.sg)*10, na.rm = TRUE))/10
zlim <- c(floor(min(zlim[1]*10, values(r.gsm.sg)*10, na.rm=TRUE)),
          ceiling(max(zlim[2]*10, values(r.gsm.sg)*10, na.rm=TRUE)))/10
if (exists("r.p.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.p.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.p.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.psu.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.psu.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.psu.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.landgis.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.landgis.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.landgis.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.issr8.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.issr8.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.issr8.sg)*10, na.rm=TRUE)))/10
}
```

## Histograms
    
The property and depth will be given in the caption, if this is used in a publication.

First, compute the maximum density, to have a common y-axis:

```{r hist.densities}
max.dens <- function(r.map) {  # argument: the raster map
  h <- hist(r.map,  breaks=24, plot = FALSE)
  max(h$counts/(diff(h$breaks[1:2]))/sum(h$counts))
}
yl <- max(max.dens(r.gsm.sg), max.dens(r.sg))
if (exists("r.p.sg")) { yl <- max(yl, max.dens(r.p.sg))}
if (exists("r.psu.sg")) { yl <- max(yl, max.dens(r.psu.sg))}
if (exists("r.landgis.sg")) { yl <- max(yl, max.dens(r.landgis.sg))}
if (exists("r.issr8.sg")) { yl <- max(yl, max.dens(r.issr8.sg))}
```

Use this y-axis to show all the histograms together:

```{r hist.sg.props, fig.width=15, fig.height=10}
yl <- c(0, yl) # standardize the density axis
par(mfrow=c(2,3))
hist(r.gsm.sg, breaks=24, main="GSM v0.5",
     xlim=zlim, xlab="", freq = FALSE, ylim=yl)
hist(r.sg, breaks=24, main="SoilGrids250",
     xlim=zlim, xlab="", freq = FALSE, ylim=yl)
if (exists("r.p.sg")) {
  hist(r.p.sg, breaks=24, main="POLARIS",
       xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
if (exists("r.psu.sg")) {
  hist(r.psu.sg, breaks=24, main="SPCG100",
       xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
if (exists("r.landgis.sg")) {
  hist(r.landgis.sg, breaks=24, main="LandGIS",
       xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
if (exists("r.issr8.sg")) {
  hist(r.issr8.sg, breaks=24, main="ISSR-800",
       xlim=zlim, xlab="", freq = FALSE, ylim=yl)
}
par(mfrow=c(1,1))
```

## Maps


```{r map.sg.props, fig.width=18, fig.height=12}
par(mfrow=c(2,3))
terra::plot(r.gsm.sg, main="GSM v0.5", range=zlim)
terra::plot(r.sg, main="SoilGrids", range=zlim)
if (exists("r.p.sg")) {
  terra::plot(r.p.sg, main="POLARIS", range=zlim)
}
if (exists("r.psu.sg")) {
  terra::plot(r.psu.sg, main="SPCG100", range=zlim)
}
if (exists("r.landgis.sg")) {
  terra::plot(r.landgis.sg, range=zlim, main="LandGIS")
}
if (exists("r.issr8.sg")) {
  terra::plot(r.issr8.sg, range=zlim, main="ISSR-800")
}
par(mfrow=c(1,1))
```

## Correlations

Pairwise Pearson correlations. Note the distributions are fairly symmetric/quasi-normal so Pearson's correlations are valid.

```{r pairwise}
v.all <- data.frame(gsm=values(r.gsm.sg),
                    sg=values(r.sg),
                    polaris=values(r.p.sg),
                    psu=values(r.psu.sg),
                    landgis=values(r.landgis.sg),
                    issr8=values(r.issr8.sg))
dim(v.all)
cor.all <- cor(v.all, use="pairwise.complete.obs")
cor.upper <- cor.all; cor.upper[lower.tri(cor.upper)] <- NA
print(round(cor.upper, 3))
```

Make a nice correlation plot:

```{r corrplot, fig.width=5, fig.height=5}
library(corrplot)
corrplot(cor.all, method="circle", type="upper", diag=FALSE)
```



# Differences 

## Compute all differences

Relative to GSM v0.5, as the base product closest to the field soil survey.

```{r}
diff.gsm.sg <- r.gsm.sg - r.sg
if (exists("r.p.sg")) {
  diff.gsm.p <-  r.gsm.sg - r.p.sg }
if (exists("r.psu.sg")) {
  diff.gsm.psu <-  r.gsm.sg - r.psu.sg }
if (exists("r.landgis.sg")) {
  diff.gsm.landgis <-  r.gsm.sg - r.landgis.sg }
if (exists("r.issr8.sg")) {
  diff.gsm.issr8 <-  r.gsm.sg - r.issr8.sg }
```

## Statistics

RMSE, ME, RMSE adjusted to ME, for all products compared to GSM v0.5:

```{r stats.compare.sg, warning=FALSE}
stats.compare <- data.frame(PSM_product = "", MD = 0, RMSD = 0, RMSD.Adjusted = 0)
rmse <- function(v1, v2) {
  round(sqrt(mean((v1-v2)^2, na.rm=TRUE)),3)
}
me <- function(v1, v2) { 
  round(mean(v1-v2, na.rm=TRUE), 3)
}
rmse.adj <- function(v1, v2) {   # RMSE adjusted for ME (bias)
  me <- mean(v1-v2, na.rm=TRUE)
  v2.adj <- v2 + me
  round(sqrt(mean((v1-v2.adj)^2, na.rm=TRUE)),3)
}
stats.compare[1, ] <- c("SoilGrids250",
                        me(values(r.gsm.sg),values(r.sg)),
                        rmse(values(r.gsm.sg),values(r.sg)),
                        rmse.adj(values(r.gsm.sg),values(r.sg))
)
if (exists("r.p.sg")) {
  stats.compare[2, ] <- c("POLARIS",
                        me(values(r.gsm.sg),values(r.p.sg)),
                        rmse(values(r.gsm.sg),values(r.p.sg)),
                        rmse.adj(values(r.gsm.sg),values(r.p.sg))
                        )
}
if (exists("r.psu.sg")) {
  stats.compare[3, ] <- c("SPCG100",
                        me(values(r.gsm.sg),values(r.psu.sg)),
                        rmse(values(r.gsm.sg),values(r.psu.sg)),
                        rmse.adj(values(r.gsm.sg),values(r.psu.sg))
                        )
}
if (exists("r.landgis.sg")) {
  stats.compare[4, ] <- c("LandGIS",
                        me(values(r.gsm.sg),values(r.landgis.sg)),
                        rmse(values(r.gsm.sg),values(r.landgis.sg)),
                        rmse.adj(values(r.gsm.sg),values(r.landgis.sg))
                        )
}
if (exists("r.issr8.sg")) {
  stats.compare[5, ] <- c("ISSR-800",
                        me(values(r.gsm.sg),values(r.issr8.sg)),
                        rmse(values(r.gsm.sg),values(r.issr8.sg)),
                        rmse.adj(values(r.gsm.sg),values(r.issr8.sg))
                        )
}
```

Save this table for incorporation in a LaTeX document:

```{r save.stats.compare.sg}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(stats.compare, row.names=FALSE, digits=3)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), 
               file=paste0("../LaTeX_tables/SoilGrids250_compare_statistics_",
                           AOI.dir.prefix, "_", voi.sg, "_", depth, ".tex"))
```

## Compute common range for all differences

```{r zlim.diff.sg}
zlim <- c(NA, NA)
zlim <- c(floor(min(zlim[1]*10, values(diff.gsm.sg)*10, na.rm=TRUE)),
          ceiling(max(zlim[2]*10, values(diff.gsm.sg)*10, na.rm=TRUE)))/10
if (exists("diff.gsm.p")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.gsm.p)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.gsm.p)*10, na.rm=TRUE)))/10
}
if (exists("diff.gsm.psu")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.gsm.psu)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.gsm.psu)*10, na.rm=TRUE)))/10
}
if (exists("diff.gsm.landgis")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.gsm.landgis)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.gsm.landgis)*10, na.rm=TRUE)))/10
}
if (exists("diff.gsm.issr8")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.gsm.issr8)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.gsm.issr8)*10, na.rm=TRUE)))/10
}
print(zlim)
```

## Histograms

First, compute the maximum density, to have a common y-axis:

```{r diff.hist.densities}
yl <- max(max.dens(diff.gsm.sg))
if (exists("r.p.sg")) { yl <- max(yl, max.dens(diff.gsm.p))}
if (exists("r.psu.sg")) { yl <- max(yl, max.dens(diff.gsm.psu))}
if (exists("r.landgis.sg")) { yl <- max(yl, max.dens(diff.gsm.landgis))}
if (exists("r.issr8.sg")) { yl <- max(yl, max.dens(diff.gsm.issr8))}
```

Use this y-axis to show all the histograms together:


```{r hist.diff.sg, fig.width=15, fig.height=10}
yl <- c(0, yl) # Standardize density axis
par(mfrow=c(2,3))
hist(diff.gsm.sg, main="GSM v0.5 - SoilGrids250", xlab="",
     xlim=zlim,  breaks=24, freq = FALSE, ylim=yl)
if (exists("r.p.sg")) {
  hist(diff.gsm.p, main="GSM v0.5 - POLARIS", xlab="",
     xlim=zlim,  breaks=24, freq = FALSE, ylim=yl)
}
if (exists("r.psu.sg")) {
  hist(diff.gsm.psu, main="GSM v0.5 - SPCG100USA", xlab="",
     xlim=zlim,  breaks=24, freq = FALSE, ylim=yl)
}
if (exists("r.landgis.sg")) {
  hist(diff.gsm.landgis, main="GSM v0.5 - LandGIS", xlab="",
     xlim=zlim,  breaks=24, freq = FALSE, ylim=yl)
}
if (exists("r.issr8.sg")) {
  hist(diff.gsm.p, main="GSM v0.5 - ISSR-800", xlab="",
     xlim=zlim,  breaks=24, freq = FALSE, ylim=yl)
}
par(mfrow=c(1,1))
```


## Maps

```{r plot.diff.sg, fig.width=15, fig.height=10}
par(mfrow=c(2,3))
terra::plot(diff.gsm.sg, main="Difference GSM v0.5 - SoilGrids250",
            range=zlim, col=bpy.colors(64))
if (exists("diff.gsm.p")) {
  terra::plot(diff.gsm.p, main="Difference GSM v0.5 - POLARIS",
            range=zlim, col=bpy.colors(64))
}
if (exists("diff.gsm.psu")) {
  terra::plot(diff.gsm.psu, main="Difference GSM v0.5 - SPCG100USA",
            range=zlim, col=bpy.colors(64))
}
if (exists("diff.gsm.landgis")) {
  terra::plot(diff.gsm.landgis, main="Difference GSM v0.5 - LandGIS",
            range=zlim, col=bpy.colors(64))
}
if (exists("diff.gsm.issr8")) {
  terra::plot(diff.gsm.issr8, main="Difference GSM v0.5 - ISSR-800",
            range=zlim, col=bpy.colors(64))
}
par(mfrow=c(1,1))
```

# Save harmonized maps {#save}

Set up a directory for these, based on the AOI:

```{r save.dir}
dest.dir.save <-  file.path(base.dir.export,
                       AOI.dir.prefix)
if (!dir.exists(dest.dir.save)) {
   dir.create(dest.dir.save, recursive = TRUE)
}
```

Same AOI, CRS, resolution, units of measure:

```{r save.tiles}
# SoilGrids250
voi.depth.sg <- paste0(voi.sg, "_", depth.list.sg[depth])
dest.name <- paste0(dest.dir.save,"/sg_tile_250_",  voi.depth.sg, ".tif")
f <- terra::writeRaster(r.sg, file=dest.name,
                        overwrite=TRUE,
                        wopt=list(gdal=c("TFW=YES"), datatype="FLT4S"),
                        filetype="GTiff")
GDALinfo(dest.name)
# GSM v0.5
dest.name <- paste0(dest.dir.save,"/gsm_tile_250_",  voi.depth.sg, ".tif")
f <- terra::writeRaster(r.gsm.sg, file=dest.name,
                 overwrite=TRUE,
                 wopt=list(gdal=c("TFW=YES"), datatype="FLT4S"),
                 filetype="GTiff")
GDALinfo(dest.name)
# SPCG100USA
if (exists("r.psu.sg")) {
  dest.name <- paste0(dest.dir.save,"/psu_tile_250_",  voi.depth.sg, ".tif")
  f <- terra::writeRaster(r.psu.sg, file=dest.name,
                          overwrite=TRUE, 
                          wopt=list(gdal=c("TFW=YES"), datatype="FLT4S"),
                          filetype="GTiff")
  GDALinfo(dest.name)
}
# POLARIS
if (exists("r.p.sg")) {
  dest.name <- paste0(dest.dir.save,"/polaris_tile_250_",  voi.depth.sg, ".tif")
  f <- terra::writeRaster(r.p.sg, file=dest.name,
            overwrite=TRUE,
            wopt=list(gdal=c("TFW=YES"), datatype="FLT4S"),
            filetype="GTiff")
  GDALinfo(dest.name)
}
# LandGIS
if (exists("r.landgis.sg")) {
  dest.name <- paste0(dest.dir.save,"/landgis_tile_250_",  voi.depth.sg, ".tif")
  f <- terra::writeRaster(r.landgis.sg, file=dest.name,
            overwrite=TRUE, 
            wopt=list(gdal=c("TFW=YES"), datatype="FLT4S"),
            filetype="GTiff")
  GDALinfo(dest.name)
}
# ISSR-800
if (exists("r.issr8.sg")) {
  dest.name <- paste0(dest.dir.save,"/issr8_tile_250_",  voi.depth.sg, ".tif")
  f <- terra::writeRaster(r.issr8.sg, file=dest.name,
            overwrite=TRUE,
            wopt=list(gdal=c("TFW=YES"), datatype="FLT4S"),
            filetype="GTiff")
  GDALinfo(dest.name)
}
```
