---
title: "Comparing PSM products at regional resolution"
author: "D G Rossiter"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_align: center
    fig_height: 6
    fig_width: 6
    number_section: yes
    theme: spacelab
    df_print: paged
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = 'center',
                      fig.path = './figs/compare_sg/')
knitr::opts_chunk$set(cache.extra = R.version.string)
```

# Introduction

This script compares PSM products at 250 m grid resolution, which is used by SoilGrids250.
We consider this an appropriate resolution for regional studies.

Depending on the [property of interest](#voi), the following can be compared:

* [SoiLGrids250](https://www.isric.org/explore/soilgrids)  from ISRIC further abbreviated as _SG2_;
* [Global Soil Map v0.5 for the USA](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/research/?cid=nrcseprd1321715), further abbreviated as _GSMv05_;
* [Intermediate-scale gridded soil property and interpretation maps from averaged and aggregated SSURGO and STATSGO data](https://github.com/ncss-tech/ISSR-800), further abbreviated as _ISSR-800_;
* POLARIS Soil Properties;
* [Soil Properties and Class 100m Grids USA](https://doi.org/10.18113/S1KW2H), further abbreviated as _SPCG100USA_;
* [LandGIS](https://opengeohub.org/about-landgis) from the private company [EnvirometriX](http://envirometrix.nl/).

The PSM products must have been previously imported and restricted to the same area of interest (AOI), typically $1 \times 1^\circ$, to the locations indicated in the directory list.


# Setup

## Packages

```{r}
library(rgdal)     # R interface to GDAL
library(terra)     # for raster maps
library(sf)        # Simple Features spatial data
library(gridExtra)  # arrange multiple plots
library(knitr)      # for fancy tables
library(xtable)     # (same)
```

## Base directory paths

Set base directories, specific to the local file system. 

1. `base.dir`: This is the location of the PSM tiles that have been cropped to an AOI.

2. `base.dir.import`: This is where downloaded large GeoTIFF are located. Because of their size they may be on a separate file system, e.g., removable or networked drive. In this script this location is only used for POLARIS, since they are imported directly as $1 \times 1^\circ$ tiles.

```{r}
base.dir <- "/Users/rossiter/ds/"
base.dir.sg <- paste0(base.dir, "SoilGrids250")
base.dir.gsm <- paste0(base.dir, "GSM_USA")
base.dir.issr8 <- paste0(base.dir, "ISSR8")
base.dir.polaris <- paste0(base.dir, "POLARIS")
base.dir.psu <- paste0(base.dir, "SPCG100USA")
base.dir.landgis <- paste0(base.dir, "LandGIS")
# POLARIS tiles are large, they were imported to the "raw import" volume
base.dir.import <- "/Volumes/Pythagoras/ds/"
base.dir.polaris.import <- paste0(base.dir.import, "POLARIS")
```

# Property of interest {#voi}

Property names in various systems. Note that all by SoilGrids250 are missing one or more properties.
These maps will be omitted from comparisons for those properties.

```{r}
# clay, silt, sand, pH, CEC, SOC, bulk density, coarse fragments
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.list.gsm <- c("claytotal_r_g_kg", "silttotal_r_g_kg", "sandtotal_r_g_kg", 
                  "ph1to1h2o_r_ions_pHx10", "ecec_r_cmolc_kg", "soc_r_mr_g_gF",
                  "dbthirdbar_lt2mm_r_g_cm3", "gravel_r_vol_ratio_m3_m3")
voi.list.issr8 <- c("clay", "silt","sand","ph", "cec", "", "", "")
voi.list.polaris <- c("clay", "silt", "sand", "ph", "", "om", "bd", "") 
voi.list.psu <- c("clay", "", "sand", "ph_h2o", "", "soc", "bd", "")
voi.list.landgis <- c("clay.wfraction_usda.3a1a1a",
                      "silt.wfraction_usda.3a1a1a",
                      "sand.wfraction_usda.3a1a1a",
                      "ph.h2o_usda.4c1a2a",
                      "",
                      "organic.carbon_usda.6a1c",
                      "bulkdens.fineearth_usda.4a1h",
                      "coarsefrag.vfraction_usda_3b1")
```

For more on the SoilGrids properties see [here](https://www.isric.org/explore/soilgrids/faq-soilgrids).

For POLARIS properties see [this file](http://hydrology.cee.duke.edu/POLARIS/PROPERTIES/v1.0/Readme).

Select the position in these lists

```{r}
voi <- 4
voi.sg <- voi.list.sg[voi]
voi.issr8 <- voi.list.issr8[voi]
voi.polaris <- voi.list.polaris[voi]
voi.psu <- voi.list.psu[voi]
voi.gsm <- voi.list.gsm[voi]
```

# Depth of interest {#depth}

Depth slices:

```{r}
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
# SPCGUSA100 predicts at points, these were averaged to GSM slices during import
# --- these have the SG names
# LandGIS predicts at points, these were averaged to GSM slices during import
# --- these have the SG names
depth.list.polaris <- gsub("-", "_", depth.list.sg)
depth.list.issr8 <- gsub("-", "", depth.list.sg)
depth.list.gsm <- c("000_005", "005_015", "015_030", "030_060", "060_100", "100_200")
```

Select the depth slice:

```{r}
depth <- 1
```

Add depth to ISSR-800 property name:

```{r}
voi.issr8 <- paste0(voi.issr8, "_", depth.list.issr8[depth])
```


# Area of Interest (AOI) {#aoi}

We use a $1 \times 1^\circ$ tile, because that is how POLARIS data is served.
Specify the lower-right corner, then compute the upper-right corner 1 degree west and north.

Specify the two corners using WGS84 geographic coordinates:

Specify the lower-right corner:

```{r lrc}
tile.lrc <- c(-76, 42)   # lower-right corner
tile.size <- 1
```

Compute the upper-left coner:

```{r ulc}
tile.ulc <- c(tile.lrc[1]-tile.size, tile.lrc[2]+tile.size) # upper-left corner
```

A prefix for directories, to keep AOI results separate.

```{r}
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
                         "_lon", tile.ulc[1], tile.lrc[1])
```


A prefix for directories, to keep AOI results separate.

```{r}
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
                         "_lon", tile.ulc[1], tile.lrc[1])
```

Set up a directory for the products, separated by AOI:

```{r}
dest.dir.issr8 <-  file.path(base.dir.issr8,
                       AOI.dir.prefix)
if (!dir.exists(dest.dir.issr8)) {
   dir.create(dest.dir.issr8,recursive = TRUE)
}
```

Bounding box:

```{r bbox.4326}
m <- matrix(c(tile.ulc[1],tile.lrc[1],  #ulc
              tile.ulc[2], tile.lrc[2]), nrow=2) #lrc
bb.ll <- st_sfc(st_multipoint(m))
st_crs(bb.ll) <- 4326   # ESPG code for WGS84 long/lat
```

Project the bounding box to Goode Interrupted Homolosine (IGH) used by SoilGrids:

```{r bbox.igh}
# convert to Homolosine. Note epsg=152160 is not in PROJ4 database
crs.igh <- '+proj=igh +lat_0=0 +lon_0=0 +datum=WGS84 +units=m +no_defs'
(bb.igh <- st_transform(bb.ll, crs.igh))
(bb.igh <- st_coordinates(bb.igh)[,1:2])
(bb <- as.vector(t(bb.igh)))
```

Project the bounding box to the AEA. This is the CRS used by ISSR-800 and SPCG100USA:

```{r bbox.aea}
crs.aea <- "+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
(bb.aea <- st_transform(bb.ll, crs.aea))
```

# Products to compare

Load the tiles in their native CRS, as processed in the import scripts.

## SoilGrids250

This is required; all the properties to compare are mapped by SoilGrids250.

```{r get.tiles.sg}
# SoilGrids250 -- only the mean prediction in this script
# Use the EPSG:4326 version
src.dir <-  paste0(base.dir.sg ,"/", 
                   AOI.dir.prefix, "/", 
                   voi.sg, "/mean/",
                   depth.list.sg[depth], "cm")
(voi.depth.name <- paste0(voi.sg, "_", depth.list.sg[depth], "cm_mean_4326"))
(file.name <- paste0(src.dir, "/", voi.depth.name, '.tif'))
if (file.exists(file.name)) {
  r.sg <- terra::rast(file.name)
  names(r.sg) <- "SoilGrids250"
  print(r.sg)
} else { stop("No SoilGrids250 tile, stopping") }
```

## GSM

```{r get.tiles.gsm}
# GSM
src.dir <-  paste0(base.dir.gsm ,"/", AOI.dir.prefix)
voi.depth.name <- paste0(voi.gsm, "_", depth.list.gsm[depth])
(file.name <- paste0(src.dir, "/GSM_mu_", voi.depth.name, ".tif"))
file.exists(file.name)
if (file.exists(file.name)) {
  r.gsm <- terra::rast(file.name)
  names(r.gsm) <- "GSMv0.5"
  print(r.gsm)
}
```



## SPCG100USA

```{r get.tiles.psu}
# SPCG100USA
src.dir <-  paste0(base.dir.psu ,"/", AOI.dir.prefix)
(file.name <- paste0(src.dir, "/", voi.psu, "_", depth.list.sg[depth], '.tif'))
if (file.exists(file.name)) {
  r.psu <- terra::rast(file.name)
  names(r.psu) <- "spcg100usa"
  print(r.psu)
}
```

## POLARIS

```{r get.tiles.polaris}
# POLARIS -- only the mean prediction in this script
(file.name <- paste0(base.dir.polaris.import, "/",
                     AOI.dir.prefix, "/",
                     voi.list.polaris[voi], "/mean/",
                     depth.list.polaris[depth], "/",
                     AOI.dir.prefix, ".tif"))
if (file.exists(file.name)) {
  r.p <- terra::rast(file.name)
  names(r.p) <- "polaris"
  print(r.p)
}
```

## LandGIS

```{r get.tiles.landgis}
# LandGIS -- only the mean prediction in this script
(file.name <- paste0(base.dir.landgis, "/",
                     AOI.dir.prefix, "/",
                     voi.list.landgis[voi], "_",
                     depth.list.sg[depth],
                     ".tif"))
if (file.exists(file.name)) {
  r.landgis <- terra::rast(file.name)
  names(r.landgis) <- "landgis"
  print(r.landgis)
}
```

## ISSR-800


```{r get.tiles.issr8}
(file.name <- paste0(base.dir.issr8, "/",
                     AOI.dir.prefix, "/",
                     voi.list.issr8[voi], "_",
                     depth.list.issr8[depth],
                     ".tif"))
if (file.exists(file.name)) {
  r.issr8 <- terra::rast(file.name)
  names(r.issr8) <- "ISSR-800"
  print(r.issr8)
}
```

# Make the units compatible

Depending on the property, data in some coverages need to be converted to the units used in SoilGrids250; we choose this as the base; note these are integers. Here are the units:

```{r show.conversions}
df <- data.frame(property=voi.list.sg, 
                 #"clay"  "silt"  "sand"  "phh2o" "cec"   "soc"   "bdod"  "cfvo" 
                 gsm=c("%%","%%","%%","pHx10","cmol(c)/kg","g/gF","Mg/m3", "m3/m3"),  # GSM
                 sg=c("%%","%%","%%","pHx10","mmol(c)/kg","dg/kg","cg/cm3", "cm3/dm3"),  #SG
                 p=c("%","%", "%","pH","", "log10(%)", "g/cm3", ""),  # POLARIS
                 spcg=c("%","%","%","pHx10", "", "%","g/cm3", ""),  # SPCG100USA
                 lgis=c("%","%","%","pHx10","","5g/Kg","10 kg/m3", "%"),  # LandGIS
                 issr=c("%","%","%","pH","cmol(+)/kg","","g/cm3", "%")  # ISSR-800
                 )
knitr::kable(
  df, caption = 'Properties and units of measure',
  col.names=c("Property", "GlobalSoilMap","SoilGrids","POLARIS", "SPCG100USA", "LandGIS", "ISSR-800"),
  booktabs = TRUE)
```  

Make a matrix with the conversions to SoilGrids250 units. These factors *multiply* the source, to match SoilGrids250. `NA` values indicate that the property is not included in the source.

Some conversions are given [here](https://www.isric.org/explore/soilgrids/faq-soilgrids#What_do_the_filename_codes_mean).

```{r make.conversion.matrix}
conversions <- data.frame(property=voi.list.sg, 
                 # sg=c("%%","%%","%%","pHx10","mmol(c)/kg","dg/kg","cg/cm3", "cm3/dm3"), #SG
                 gsm=c(1, 1, 1, 1 , 10, 0.01, 0.01, 0.1),  # GSM
                 p=c(10,  10, 10,  10, NA, NA, 100, NA),  # POLARIS -- SOM is special case
                 spcg=c(10,  10, 10, 1, NA,  1,   100, NA),  # SPCG100USA
                 lgis=c(10,  10, 10, 1, NA, 20, 0.1, 0.1),  # LandGIS
                 issr=c(10,  10, 10,  10, 10, NA, 1, 0.1)  # ISSR-800
                 )
knitr::kable(
  conversions, caption = 'Conversion factors, multiply by these to match SoilGrids250',
  col.names=c("Property","GlobalSoilMap", "POLARIS", "SPCG100USA", "LandGIS", "ISSR-800"),
  booktabs = TRUE)
```

Convert units as necessary:

```{r convert}
(factors <- conversions[match(voi.sg, conversions$property),])
if (exists("r.gsm")) {
  fact <- as.numeric(factors[2])
  if (!is.na(fact) && (fact != 1)) { r.gsm <- r.gsm*fact }
}
if (exists("r.p")) {
  fact <- as.numeric(factors[3])
  if (!is.na(fact) && (fact != 1)) { r.p <- r.p*fact }
}
if (exists("r.psu")) {
  fact <- as.numeric(factors[4])
  if (!is.na(fact) && (fact != 1)) { r.psu <- r.psu*fact }
}
if (exists("r.landgis")) {
  fact <- as.numeric(factors[5])
  if (!is.na(fact) && (fact != 1)) { r.landgis <- r.landgis*fact }
}
if (exists("r.issr8")) {
  fact <- as.numeric(factors[6])
  if (!is.na(fact) && (fact != 1)) { r.issr8 <- r.issr8*fact }
}
```

Note that SOC for POLARIS is a special case, because of the log10-scale, and because it is SOM, not SOC. Use the conventional conversion factor 0.58 = 1/1.724138.

```{r polaris.soc}
if (exists("r.p") && (voi.sg=="soc")) {
    r.p <- ((10^r.p)*0.58*1000) 
}
```

```{r eval=FALSE}
cbind(summary(r.sg),
summary(r.p),
summary(r.gsm),
summary(r.psu),
summary(r.landgis),
summary(r.issr8))
```

# Match resolution and CRS

SoilGrids250, GSM v0.5, POLARIS and LandGIS are in EPSG:4326 (WGS84 long/lat), at different grid resolutions.

```{r crs.show.1}
rgdal::showP4(crs(r.sg))
data.frame(sg=res(r.sg)[1], 
           polaris=ifelse(exists("r.p"), res(r.p)[1], ""),
           gsm=ifelse(exists("r.gsm"), res(r.gsm)[1], ""),
           landgis=ifelse(exists("r.landgis"), res(r.landgis)[1], ""))
```

ISSR-800 and SPCG100USA are in a CONUS Albers Equal Area, but with slightly different definitions of the datums, also with different resolutions (800 and 100 m, respectively). The GRS80 ellipsoid is the basis of the NAD83 datum, and centred with WGS84, so there effectively no difference.

```{r crs.show.2}
if (exists("r.psu")) rgdal::showP4(crs(r.psu))
if (exists("r.issr8")) rgdal::showP4(crs(r.issr8))
```

Resample products into SoilGrids250 WGS84, using cubic interpolation.


```{r crs.resample}
if (exists("r.p")) { r.p.sg <- terra::resample(r.p, r.sg) }
if (exists("r.gsm")) { r.gsm.sg <- terra::resample(r.gsm, r.sg) }
if (exists("r.psu")) { r.psu.sg <- terra::resample(r.psu, r.sg) }
if (exists("r.landgis")) { r.landgis.sg <- terra::resample(r.landgis, r.sg) }
if (exists("r.issr8")) { r.issr8.sg <- terra::resample(r.issr8, r.sg) }
```


# Make all maps cover the same area

POLARIS predicts in the lakes, for example.

```{r mask.lakes}
if (exists("r.p.sg")) { r.p.sg <- mask(r.p.sg, r.sg) }
```

Mask from SoilGrids to get consistent coverge:

```{r}
if (exists("r.issr.sg")) { r.issr.sg <- mask(r.issr8.sg, r.sg) }
if (exists("r.psu.sg")) { r.psu.sg <- mask(r.psu.sg, r.sg) }
if (exists("r.gsm.sg")) { r.gsm.sg <- mask(r.gsm.sg, r.sg) }
if (exists("r.landgis.sg")) { r.landgis.sg <- mask(r.landgis.sg, r.sg) }
```

Check that the maps cover the same area, ignore different stretches for now:

```{r plot.resampled, fig.width=8, fig.height=12}
par(mfrow=c(3, 2))
plot(r.sg, main="SoilGrids250")
if (exists("r.p.sg")) { plot(r.p.sg, main="POLARIS") }
if (exists("r.gsm.sg")) { plot(r.gsm.sg, main="GSM v0.5") }
if (exists("r.psu.sg")) { plot(r.psu.sg, main="SPCG100USA") }
if (exists("r.landgis.sg")) { plot(r.landgis.sg, main="LandGIS") }
if (exists("r.issr8.sg")) { plot(r.issr8.sg, main="ISSR-800") }
par(mfrow=c(1, 1))
```


# Compare

## Compute common range for all products

```{r compare.zlim}
zlim <- c(min(values(r.sg)*10, na.rm = TRUE),
          max(values(r.sg)*10, na.rm = TRUE))/10
if (exists("r.p.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.p.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.p.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.psu.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.psu.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.psu.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.gsm.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.gsm.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.gsm.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.landgis.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.landgis.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.landgis.sg)*10, na.rm=TRUE)))/10
}
if (exists("r.issr8.sg")) {
  zlim <- c(floor(min(zlim[1]*10, values(r.issr8.sg)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(r.issr8.sg)*10, na.rm=TRUE)))/10
}
```

## Histograms

** Standardize frequency (density?) axis
    
The property and depth will be given in the caption, if this is used in a publication.

```{r hist.sg.props, fig.width=12, fig.height=18}
par(mfrow=c(3,2))
hist(r.sg, main="SoilGrids250", xlim=zlim, xlab="")
if (exists("r.p.sg")) {
  hist(r.p.sg, main="POLARIS", xlim=zlim, xlab="")
}
if (exists("r.psu.sg")) {
  hist(r.psu.sg, main="SPCG100", xlim=zlim, xlab="")
}
if (exists("r.gsm.sg")) {
  hist(r.gsm.sg, main="GSM v0.5", xlim=zlim, xlab="")
}
if (exists("r.landgis.sg")) {
  hist(r.landgis.sg, main="LandGIS", xlim=zlim, xlab="")
}
if (exists("r.issr8.sg")) {
  hist(r.issr8.sg, main="ISSR-800", xlim=zlim, xlab="")
}
par(mfrow=c(1,1))
```

## Maps


```{r map.sg.props, fig.width=12, fig.height=18}
par(mfrow=c(3,2))
terra::plot(r.sg, range=zlim, main="SoilGrids")
if (exists("r.p.sg")) {
  terra::plot(r.p.sg, main="POLARIS", range=zlim)
}
if (exists("r.psu.sg")) {
  terra::plot(r.psu.sg, main="SPCG100", range=zlim)
}
if (exists("r.gsm.sg")) {
  terra::plot(r.gsm.sg, main="GSM v0.5", range=zlim)
}
if (exists("r.landgis.sg")) {
  terra::plot(r.landgis.sg, range=zlim, main="LandGIS")
}
if (exists("r.issr8.sg")) {
  terra::plot(r.issr8.sg, range=zlim, main="ISSR-800")
}
par(mfrow=c(1,1))
```

<!-- To here  -->



# Differences 

## Compute all differences

** Relative to SoilGrids250 -- should be GSM v0.5?

```{r}
if (exists("r.p.sg")) {
  summary(diff.sg.p <-  r.sg - r.p.sg) }
if (exists("r.psu.sg")) {
  summary(diff.sg.psu <-  r.sg - r.psu.sg) }
if (exists("r.gsm.sg")) {
  summary(diff.sg.gsm <-  r.sg - r.gsm.sg) }
if (exists("r.landgis.sg")) {
  summary(diff.sg.landgis <-  r.sg - r.landgis.sg) }
if (exists("r.issr8.sg")) {
  summary(diff.sg.issr8 <-  r.sg - r.issr8.sg) }
```

## Statistics

RMSE, ME, RMSE adjusted to ME, for all products compared to SoilGrids250:

```{r stats.compare.sg, warning=FALSE}
stats.compare <- data.frame(PSM_product = "", MD = 0, RMSD = 0, RMSD.Adjusted = 0)
rmse <- function(v1, v2) {
  round(sqrt(mean((v1-v2)^2, na.rm=TRUE)),3)
}
me <- function(v1, v2) { 
  round(mean(v1-v2, na.rm=TRUE), 3)
}
rmse.adj <- function(v1, v2) {   # RMSE adjusted for ME (bias)
  me <- mean(v1-v2, na.rm=TRUE)
  v2.adj <- v2 + me
  round(sqrt(mean((v1-v2.adj)^2, na.rm=TRUE)),3)
}
if (exists("r.gsm.sg")) {
  stats.compare[1, ] <- c("GSM v0.5",
                        me(values(r.sg),values(r.gsm.sg)),
                        rmse(values(r.sg),values(r.gsm.sg)),
                        rmse.adj(values(r.sg),values(r.gsm.sg))
                        )
}
if (exists("r.p.sg")) {
  stats.compare[2, ] <- c("POLARIS",
                        me(values(r.sg),values(r.p.sg)),
                        rmse(values(r.sg),values(r.p.sg)),
                        rmse.adj(values(r.sg),values(r.p.sg))
                        )
}
if (exists("r.psu.sg")) {
  stats.compare[3, ] <- c("SPCG100",
                        me(values(r.sg),values(r.psu.sg)),
                        rmse(values(r.sg),values(r.psu.sg)),
                        rmse.adj(values(r.sg),values(r.psu.sg))
                        )
}
if (exists("r.landgis.sg")) {
  stats.compare[4, ] <- c("LandGIS",
                        me(values(r.sg),values(r.landgis.sg)),
                        rmse(values(r.sg),values(r.landgis.sg)),
                        rmse.adj(values(r.sg),values(r.landgis.sg))
                        )
}
if (exists("r.issr8.sg")) {
  stats.compare[5, ] <- c("ISSR-800",
                        me(values(r.sg),values(r.issr8.sg)),
                        rmse(values(r.sg),values(r.issr8.sg)),
                        rmse.adj(values(r.sg),values(r.issr8.sg))
                        )
}
```

Save this table for incorporation in a LaTeX document:

```{r save.stats.compare.sg}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(stats.compare, row.names=FALSE, digits=3)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), 
               file=paste0("../LaTeX_tables/SoilGrids250_compare_statistics_",
                           AOI.dir.prefix, "_", voi.sg, "_", depth, ".tex"))
```

## Compute common range for all differences

```{r zlim.diff.sg}
zlim <- c(NA, NA)
if (exists("diff.sg.p")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.sg.p)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.sg.p)*10, na.rm=TRUE)))/10
}
if (exists("diff.sg.psu")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.sg.psu)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.sg.psu)*10, na.rm=TRUE)))/10
}
if (exists("diff.sg.gsm")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.sg.gsm)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.sg.gsm)*10, na.rm=TRUE)))/10
}
if (exists("diff.sg.landgis")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.sg.landgis)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.sg.landgis)*10, na.rm=TRUE)))/10
}
if (exists("diff.sg.issr8")) {
  zlim <- c(floor(min(zlim[1]*10, values(diff.sg.issr8)*10, na.rm=TRUE)),
            ceiling(max(zlim[2]*10, values(diff.sg.issr8)*10, na.rm=TRUE)))/10
}
print(zlim)
```

## Histograms

** Standardize frequency (density?) axis

```{r hist.diff.sg, fig.width=12, fig.height=18}
par(mfrow=c(3,2))
if (exists("r.p.sg")) {
  hist(diff.sg.p, main="SoilGrids250 - POLARIS", xlab="",
     xlim=zlim)
}
if (exists("r.psu.sg")) {
  hist(diff.sg.psu, main="SoilGrids250 - SPCG100USA", xlab="",
     xlim=zlim)
}
if (exists("r.gsm.sg")) {
  hist(diff.sg.gsm, main="SoilGrids250 - GSM v0.5", xlab="",
     xlim=zlim)
}
if (exists("r.landgis.sg")) {
  hist(diff.sg.landgis, main="SoilGrids250 - LandGIS", xlab="",
     xlim=zlim)
}
if (exists("r.issr8.sg")) {
  hist(diff.sg.p, main="SoilGrids250 - ISSR-800", xlab="",
     xlim=zlim)
}
par(mfrow=c(1,1))
```


## Maps

```{r plot.diff.sg, fig.width=12, fig.height=18}
par(mfrow=c(3,2))
if (exists("diff.sg.p")) {
  terra::plot(diff.sg.p, main="Difference SoilGrids250 - POLARIS",
            range=zlim, col=bpy.colors(64))
}
if (exists("diff.sg.psu")) {
  terra::plot(diff.sg.psu, main="Difference SoilGrids250 - SPCG100USA",
            range=zlim, col=bpy.colors(64))
}
if (exists("diff.sg.gsm")) {
  terra::plot(diff.sg.gsm, main="Difference SoilGrids250 - GSM v0.5",
            range=zlim, col=bpy.colors(64))
}
if (exists("diff.sg.landgis")) {
  terra::plot(diff.sg.landgis, main="Difference SoilGrids250 - LandGIS",
            range=zlim, col=bpy.colors(64))
}
if (exists("diff.sg.issr8")) {
  terra::plot(diff.sg.issr8, main="Difference SoilGrids250 - ISSR-800",
            range=zlim, col=bpy.colors(64))
}
par(mfrow=c(1,1))
```


