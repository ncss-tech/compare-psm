---
title: "Comparing spatial patterns of PSM maps at regional resolution"
author:
- D G Rossiter
- d.g.rossiter@cornell.edu
date: "`r format(Sys.Date(), '%d-%B-%Y')`"
params:
   lrc_long: -76
   lrc_lat: 42
   size: 1
   voi.n: 4
   quantile.n: NA
   depth.n: 1
   test.tile.size: 0.20  # degrees
   test.tile.x.offset: 0.6  # west from right edge
   test.tile.y.offset: 0.2  # north from bottom edge
output:
  html_document:
    fig_align: center
    fig_height: 5
    fig_width: 10
    number_section: yes
    theme: spacelab
    df_print: paged
    code_folding: hide
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, purl = FALSE,
                      fig.align = 'center', fig.path = './figs/compare_maps/')
knitr::opts_chunk$set(cache.extra = R.version.string)
```

# Introduction

This script compares PSM products at 250 m grid resolution, which is used by SoilGrids250.
We consider this an appropriate resolution for regional studies.

In this script we quantify the *spatial* agreement between soil maps, using several methods: (1) ["V metrics"](#vmetrics) (2) [Landscape metrics](#landscapemetrics) similar to FRAGSTATS, as used in ecology.

Depending on the [property of interest](#voi), the following can be compared.

These two are always compared:

* [gNATSGO](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/geo/?cid=nrcseprd1464625);
* [SoiLGrids250](https://www.isric.org/explore/soilgrids)  from ISRIC further abbreviated as _SG2_;

These can be included:

* [Global Soil Map v0.5 for the USA](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/research/?cid=nrcseprd1321715), further abbreviated as _GSMv05_;
* [Intermediate-scale gridded soil property and interpretation maps from averaged and aggregated SSURGO and STATSGO data](https://github.com/ncss-tech/ISSR-800), further abbreviated as _ISSR-800_;
* POLARIS Soil Properties;
* [Soil Properties and Class 100m Grids USA](https://doi.org/10.18113/S1KW2H), further abbreviated as _SPCG_;
* [LandGIS](https://opengeohub.org/about-landgis) from the private company [EnvirometriX](http://envirometrix.nl/).

This script must follow script `Compare_regional.Rmd` "Comparing PSM products at regional resolution". That script harmonizes the area of interest and resolution of these sources, and stores the harmonized products for this analysis.

To use this script:

1. Ajust the [directory structure](#dirs) to your system.

2. [Select a property](#voi) and [select a depth slice](#depth), using the YAML header or by knitting with parameters..

3. [Select an Area of Interest](#aoi), using the YAML header or by knitting with parameters.

These three can be adjusted in the YAML header; these include the default parameters and look like:

```
---
   params:
   lrc_long: -76
   lrc_lat: 42 
   size: 1
   voi.n: 4
   quantile.n: NA 
   depth.n: 4
   test.tile.size: 0.2  # degrees
   test.tile.x.offset: 0.61  # west from right edge
   test.tile.y.offset: 0.44  # north from bottom edge
---
```

4. [Select a sub-area](#sub_aoi), by default 0.2 x 0.2 degrees, within the 1 x 1 degree tile.

5. Select the [maps to compare](#which); default (always included) are gNATSGO (the base product from NRCS) and SoilGrids250 (the globally-consistent product from ISRIC).

6. Either compile to HTML or PDF ("knit"), or "Run All" within R Markdown.

Generated figures will be in directory `./figs/compare_maps/`, in a subdirectory named for the AOI. The file name includes the PSM method, property and depth slice.

Generated tables in \LaTeX format will be in directory `../LaTeX_tables`. The table names include AOI, property and depth slice.

# Setup

## Maps to compare {#which}

This vector names the products, other than gNATSGO and SoilGrids250, to include in the comparison. This string will be checked before importing a product; if the product is either not named here or not imported at all, it will not be included in the analysis.

```{r compare.which}
products <- c("POLARIS", "SPCG100USA") #, "LandGIS", "ISSR-800", "GSM v0.5"
```

Based on the number of products, set some variables to be used in formatting figures:

```{r}
n.products <- 2 + length(products)
n.figs.row <- ceiling(sqrt(n.products))
n.figs.col <- ceiling(n.products/n.figs.row)
map.fig.width <- n.figs.col*5
map.fig.height <- n.figs.row*5
```

## Packages

```{r}
library(raster, warn.conflicts=FALSE)      # previous version of raster classes now in `terra`
                     #   needed for landscape metrics
library(terra, warn.conflicts=FALSE)       # Robert Hijmans raster and vector data
library(rgdal)       # CRS
library(sp)          # `sp` spatial classes
library(sf)          # Simple Features
require(xtable)      # format tables for LaTeX
library(dplyr)       # data wrangling
library(ggplot2)     # ggplot graphics
library(gridExtra)
library(RColorBrewer)
library(sabre)       # compare polygon map spatial structure
library(landscapemetrics)   # FRAGSTATS metrics
library(landscapetools)
library(gstat)      # variogram modelling
```

# Local storage {#dirs}

Set the directory on the local file system, under which local files were stored by `Compare_regional.Rmd`, and where this script will store its results.

```{r}
base.dir <- "/Volumes/Pythagoras/ds/Compare_PSM/"
```

# Parameters

Parameters for this run:

```{r}
print(paste("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat, "; size:", params$size))
print(paste("voi.n:", params$voi.n, "; depth.n:", params$depth.n))
print(paste("test.tile.size:", params$test.tile.size, 
            "test.tile.x.offset:", params$test.tile.x.offset,
            "test.tile.y.offset:", params$test.tile.y.offset))
```


## Area of interest {#aoi}

We use a $1 \times 1^\circ$ tile, because that is how POLARIS data is served.

Specify the _lower-right corner_ and _tile size_ from the YAML or rendering parameters:

```{r lrc}
tile.lrc <- c(params$lrc_long, params$lrc_lat) # lower-right corner
tile.size <- params$size                # tile dimensions
```

Compute the upper-right corner $1^\circ$ west and north:

```{r ulc}
tile.ulc <- c(tile.lrc[1]-tile.size, tile.lrc[2]+tile.size) # upper-left corner
```

Set part of a file path using the AOI and property to be compared.
These names correspond to files stored by script `Compare_regional.Rmd`, which incorporate the AOI `aoi` and the property of interest and depth slice `voi`.

AOI prefix:

```{r aoi.set.dir.prefix}
(AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
                         "_lon", tile.ulc[1], tile.lrc[1]))
```


## Test area {#sub_aoi}

Because the full tile is so large, here we can choose to test on a smaller area, e.g., 0.2 x 0.2 degrees

Set the size and offset from the lower-right corner. The test area will be to the north and west of this.

```{r}
test.tile.size <- params$test.tile.size  # degrees
test.tile.x.offset <- params$test.tile.x.offset  # west from right edge
test.tile.y.offset <- params$test.tile.y.offset  # north from bottom edge
```


## Property of interest {#voi}

Set the property of interest from the YAML or rendering parameters:

```{r voi}
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.sg <- voi.list.sg[params$voi.n]
```

## Depth slice of interest {#depth}

Set the depth slice from the YAML or rendering parameters::

```{r depth}
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
voi.depth <- paste0(voi.sg, "_", depth.list.sg[params$depth.n])
```

## Adjust directory for figures

Change the location of figures generated by this script: put in subdirectories by area. 

```{r adjust.fig.path}
knitr::opts_chunk$set(fig.path = paste0(knitr::opts_chunk$get("fig.path"), 
                                        AOI.dir.prefix, "/",
                                        voi.depth, "_"))
```


# Source rasters

## Import full tiles

Load the rasters and name the data item generically as `voi`, so it can be used in expressions.

```{r}
(gnatsgo <- rast(paste0(base.dir, AOI.dir.prefix, "/gnatsgo_tile_250_", voi.depth, ".tif")))
names(gnatsgo) <- "voi"
(sg <- rast(paste0(base.dir, AOI.dir.prefix, "/sg_tile_250_", voi.depth, ".tif")))
names(sg) <- "voi"
if ("GSM v0.5" %in% products) {
  file.name <- paste0(base.dir, AOI.dir.prefix, "/gsm_tile_250_", voi.depth, ".tif")
  if (file.exists(file.name)) { print(gsm <- rast(file.name)); names(gsm) <- "voi" }
}
if ("ISSR-800" %in% products) {
  file.name <- paste0(base.dir, AOI.dir.prefix, "/issr8_tile_250_", voi.depth, ".tif")
  if (file.exists(file.name)) { print(issr8 <- rast(file.name)); names(issr8) <- "voi" }
}
if ("SPCG100USA" %in% products) {
  file.name <- paste0(base.dir, AOI.dir.prefix, "/psu_tile_250_", voi.depth, ".tif")
  if (file.exists(file.name)) { print(psu <- rast(file.name)); names(psu) <- "voi" }
}
if ("POLARIS" %in% products) {
  file.name <- paste0(base.dir, AOI.dir.prefix, "/polaris_tile_250_", voi.depth, ".tif")
  if (file.exists(file.name)) { print(polaris <- rast(file.name)); names(polaris) <- "voi" }
}
if ("LandGIS" %in% products) {
  file.name <- paste0(base.dir, AOI.dir.prefix, "/landgis_tile_250_", voi.depth, ".tif")
  if (file.exists(file.name)) { print(landgis <- rast(file.name)); names(landgis) <- "voi" }
}
```

```{r show.crs}
rgdal::showP4(crs(sg))
```

These are all in WGS84 geographic coordinates, cover the same area, and have the same no-data areas.


## Crop to test area


```{r crop.test.area}
(tmp <- as.vector(ext(sg)))
tmp["xmax"] <- tmp["xmax"] - test.tile.x.offset
tmp["xmin"] <- tmp["xmax"] - test.tile.size
tmp["ymin"] <- tmp["ymin"] + test.tile.y.offset
tmp["ymax"] <- tmp["ymin"] + test.tile.size
ext(tmp)
gnatsgo.crop <- crop(gnatsgo, ext(tmp))
sg.crop <- crop(sg, ext(tmp))
if (exists("gsm")) { gsm.crop <- crop(gsm, ext(tmp)) }
if (exists("issr8")) { issr8.crop <- crop(issr8, ext(tmp)) }
if (exists("psu")) { psu.crop <- crop(psu, ext(tmp)) }
if (exists("polaris")) { polaris.crop <- crop(polaris, ext(tmp)) }
if (exists("landgis")) { landgis.crop <- crop(landgis, ext(tmp)) }
```

## Project to metric CRS

For area calculations, we need a metric CRS, not geographic.

Determine the UTM zone and appropriate EPSG code:

```{r get.utm}
long2UTM <- function(long) { (floor((long + 180)/6) %% 60) + 1 }
utm.zone <- long2UTM(params$lrc_long+0.5)
epsg.db <- rgdal::make_EPSG()
ix <- grep(paste0("WGS 84 / UTM zone ", utm.zone, "N"), epsg.db$note)
epsg.db[ix,]
epsg.code <- epsg.db[ix, "code"]
```

Use this to resample:

```{r}
crs.utm <- paste0("+init=epsg:", epsg.code)
gnatsgo.crop <- terra::project(gnatsgo.crop, crs.utm)
sg.crop <- terra::project(sg.crop, crs.utm)
if (exists("gsm")) { gsm.crop <- terra::project(gsm.crop, crs.utm) }
if (exists("issr8")) { issr8.crop <- terra::project(issr8.crop, crs.utm) }
if (exists("psu")) { psu.crop <- terra::project(psu.crop, crs.utm) }
if (exists("polaris")) { polaris.crop <- terra::project(polaris.crop, crs.utm) }
if (exists("landgis")) { landgis.crop <- terra::project(landgis.crop, crs.utm) }
```

## Determine property range

Determine the full range of the property across all maps, to one decimal place:

```{r zlim}
values.all <- c(values(gnatsgo.crop),
                values(sg.crop))
if (exists("psu.crop")) values.all <- c(values.all, values(psu.crop))
if (exists("polaris.crop")) values.all <- c(values.all, values(polaris.crop))
if (exists("gsm.crop")) values.all <- c(values.all, values(gsm.crop))
if (exists("issr8.crop")) values.all <- c(values.all, values(issr8.crop))
if (exists("landgis.crop")) values.all <- c(values.all, values(landgis.crop))

# (zlim <- c(floor(min(values.all*10, na.rm = TRUE)),
#                ceiling(max(values.all*10, na.rm=TRUE)))/10)

(zlim <- c(min(values.all, na.rm = TRUE),
                max(values.all, na.rm=TRUE)))
```

## Display maps

Now show the maps together:

```{r side.by.side, fig.width=map.fig.width, fig.height=map.fig.height}
par(mfrow=c(n.figs.row, n.figs.col))
plot(gnatsgo.crop, main="gNATSGO", range=zlim)
plot(sg.crop, main="SG2", range=zlim)
if (exists("gsm.crop")) { plot(gsm.crop, main="GSM v0.5", range=zlim) }
if (exists("psu.crop")) plot(psu.crop, main="SPCG", range=zlim)
if (exists("polaris.crop")) plot(polaris.crop, main="PSP", range=zlim)
if (exists("landgis.crop")) plot(landgis.crop, main="LandGIS", range=zlim)
if (exists("issr8.crop")) plot(issr8.crop, main="ISSR-800", range=zlim)
par(mfrow=c(1,1))
```   


## Statistical differences (non-spatial)

```{r}
rmse <- function(v1, v2) {
  round(sqrt(mean((v1-v2)^2, na.rm=TRUE)),3)
}
me <- function(v1, v2) { 
  round(mean(v1-v2, na.rm=TRUE), 3)
}
rmse.adj <- function(v1, v2) {   # RMSE adjusted for ME (bias)
  me <- mean(v1-v2, na.rm=TRUE)
  v2.adj <- v2 + me
  round(sqrt(mean((v1-v2.adj)^2, na.rm=TRUE)),3)
}
```

```{r compare.stats}
stats.compare <- data.frame(PSM_product = "", MD = 0, RMSD = 0, RMSD.Adjusted = 0)
stats.compare[1, ] <- c("SG2",
                        me(values(gnatsgo.crop),values(sg.crop)),
                        rmse(values(gnatsgo.crop),values(sg.crop)),
                        rmse.adj(values(gnatsgo.crop),values(sg.crop))
                        )
if (exists("gsm.crop")) stats.compare[2, ] <- c("GSM v0.5",
                        me(values(gnatsgo.crop),values(gsm.crop)),
                        rmse(values(gnatsgo.crop),values(gsm.crop)),
                        rmse.adj(values(gnatsgo.crop),values(gsm.crop))
                        )
if (exists("psu.crop")) stats.compare[2, ] <- c("SPCG",
                        me(values(gnatsgo.crop),values(psu.crop)),
                        rmse(values(gnatsgo.crop),values(psu.crop)),
                        rmse.adj(values(gnatsgo.crop),values(psu.crop))
                        )
if (exists("polaris.crop")) stats.compare[3, ] <- c("PSP",
                        me(values(gnatsgo.crop),values(polaris.crop)),
                        rmse(values(gnatsgo.crop),values(polaris.crop)),
                        rmse.adj(values(gnatsgo.crop),values(polaris.crop))
                        )
if (exists("landgis.crop")) stats.compare[4, ] <- c("LandGIS",
                        me(values(gnatsgo.crop),values(landgis.crop)),
                        rmse(values(gnatsgo.crop),values(landgis.crop)),
                        rmse.adj(values(gnatsgo.crop),values(landgis.crop))
                        )
if (exists("issr8.crop")) stats.compare[5, ] <- c("ISSR8",
                        me(values(gnatsgo.crop),values(issr8.crop)),
                        rmse(values(gnatsgo.crop),values(issr8.crop)),
                        rmse.adj(values(gnatsgo.crop),values(issr8.crop))
                        )
print(stats.compare)
```

Any bias in the three will affect the cross-classification and spatial statistics. 

So also make a bias-adjusted version of the PSM products, using gNATSGO as the basis.

## Adjust for bias (systematic error)


```{r side.by.side.unbiased}
sg.adj <- sg.crop + me(values(gnatsgo.crop),values(sg.crop))
if (exists("gsm.crop")) gsm.adj <- gsm.crop + me(values(gnatsgo.crop),values(gsm.crop))
if (exists("psu.crop")) psu.adj <- psu.crop + me(values(gnatsgo.crop),values(psu.crop))
if (exists("polaris.crop")) polaris.adj <- polaris.crop + me(values(gnatsgo.crop),values(polaris.crop))
if (exists("landgis.crop")) landgis.adj <- landgis.crop + me(values(gnatsgo.crop),values(landgis.crop))
if (exists("issr8.crop")) issr8.adj <- issr8.crop + me(values(gnatsgo.crop),values(issr8.crop))
```

Recompute limits:

```{r zlim.adj}
values.all.adj <- c(values(gnatsgo.crop),
                values(sg.adj))
if (exists("psu.adj")) values.all.adj <- c(values.all.adj, values(psu.adj))
if (exists("polaris.adj")) values.all.adj <- c(values.all.adj, values(polaris.adj))
if (exists("gsm.adj")) values.all.adj <- c(values.all.adj, values(gsm.adj))
if (exists("issr8.adj")) values.all.adj <- c(values.all.adj, values(issr8.adj))
if (exists("landgis.adj")) values.all.adj <- c(values.all.adj, values(landgis.adj))

# (zlim <- c(floor(min(values.all.adj*10, na.rm = TRUE)),
#                ceiling(max(values.all.adj*10, na.rm=TRUE)))/10)

(zlim.adj <- c(min(values.all.adj, na.rm = TRUE),
                max(values.all.adj, na.rm=TRUE)))
```

These are now similar in their ranges, but not in their patterns. Compare the statistics:

```{r compare.stats.adj}
stats.compare <- data.frame(PSM_product = "", MD = 0, RMSD = 0, RMSD.Adjusted = 0)
stats.compare[1, ] <- c("SG2",
                        me(values(gnatsgo.crop),values(sg.adj)),
                        rmse(values(gnatsgo.crop),values(sg.adj)),
                        rmse.adj(values(gnatsgo.crop),values(sg.adj))
                        )
if (exists("gsm.adj")) stats.compare[2, ] <- c("GSM v0.5",
                        me(values(gnatsgo.crop),values(gsm.adj)),
                        rmse(values(gnatsgo.crop),values(gsm.adj)),
                        rmse.adj(values(gnatsgo.crop),values(gsm.adj))
                        )
if (exists("psu.adj")) stats.compare[2, ] <- c("SPCG",
                        me(values(gnatsgo.crop),values(psu.adj)),
                        rmse(values(gnatsgo.crop),values(psu.adj)),
                        rmse.adj(values(gnatsgo.crop),values(psu.adj))
                        )
if (exists("polaris.adj")) stats.compare[3, ] <- c("PSP",
                        me(values(gnatsgo.crop),values(polaris.adj)),
                        rmse(values(gnatsgo.crop),values(polaris.adj)),
                        rmse.adj(values(gnatsgo.crop),values(polaris.adj))
                        )
if (exists("landgis.adj")) stats.compare[4, ] <- c("LandGIS",
                        me(values(gnatsgo.crop),values(landgis.adj)),
                        rmse(values(gnatsgo.crop),values(landgis.adj)),
                        rmse.adj(values(gnatsgo.crop),values(landgis.adj))
                        )
if (exists("issr8.adj")) stats.compare[5, ] <- c("ISSR8",
                        me(values(gnatsgo.crop),values(issr8.adj)),
                        rmse(values(gnatsgo.crop),values(issr8.adj)),
                        rmse.adj(values(gnatsgo.crop),values(issr8.adj))
                        )
print(stats.compare)
```

Removing bias changes the spatial statistics only slightly, because the cut points in classification are the same so some pixels change classes.

So for now, _do not adjust_, use the original cropped images.

# Local spatial structure

The variogram (equivalent to correlogram) can be used to characterize the degree of spatial continuity and the "roughness" of a continuous property map. 

In this section we compute and compare the short-range variograms, these reveal the local structure. In these maps the variogram is typically unbounded, but we don't care about the long-range structure.

Convert the `terra::SpatRaster` objects to `raster::raster` and then to `sp:SpatialPointsDataFrame` in order to compute variograms. Note that there is (so far) no direct conversion. Note that `gstat::variogram` must be applied to an object of class `sp` or `sf`, not directly to a `terra::SpatRaster`.


```{r make.sp}
gnatsgo.sp <- as(raster(gnatsgo.crop), "SpatialPointsDataFrame")
sg.sp <- as(raster(sg.crop), "SpatialPointsDataFrame")
if (exists("gsm.crop")) {
  gsm.sp <- as(raster(gsm.crop), "SpatialPointsDataFrame") }
if (exists("psu.crop")) {
  psu.sp <- as(raster(psu.crop), "SpatialPointsDataFrame") }
if (exists("issr8.crop")) {
  issr8.sp <- as(raster(issr8.crop), "SpatialPointsDataFrame") }
if (exists("polaris.crop")) {
  polaris.sp <- as(raster(polaris.crop), "SpatialPointsDataFrame") }
if (exists("landgis.crop")) {
  landgis.sp <- as(raster(landgis.crop), "SpatialPointsDataFrame") }
```

## Compute and model empirical variograms

Initial parameters for empirical variograms and models. The bin width is the resolution, so we get one-grid-cell relations.

```{r}
range.init <- 1000  # m 
cutoff.init <- range.init*5  # m
width.init <- 250
```

Compute and model variograms. Note the estimated sill is the maximum $\gamma$ in the empirical variogram.

Compute the empirical variograms.


```{r compute.variogram, fig.height=6, fig.width=8}
system.time(
  v.gnatsgo <- gstat::variogram(voi ~ 1, loc = gnatsgo.sp, 
                                cutoff=cutoff.init, width=width.init)
) # system.time
# plot(v.gnatsgo, pl=T)
#
system.time(
  v.sg <- variogram(voi ~ 1, loc = sg.sp, cutoff=cutoff.init, width=width.init)
) # system.time
# plot(v.sg, pl=T)
#
if (exists("polaris.sp")) {
  system.time(
    v.polaris <- variogram(voi ~ 1, loc = polaris.sp, cutoff=cutoff.init, width=width.init)
  ) # system.time
 # plot(v.polaris, pl=T)
}
if (exists("issr8.sp")) {
  system.time(
    v.issr8 <- variogram(voi ~ 1, loc = issr8.sp, cutoff=cutoff.init, width=500)
  )
  #  plot(v.issr8, pl=T)
}
if (exists("gsm.sp")) {
  system.time(
    v.gsm <- variogram(voi ~ 1, loc = gsm.sp, cutoff=cutoff.init, width=500)
  )
  #  plot(v.gsm, pl=T)
}
if (exists("psu.sp")) {
  system.time(
    v.psu <- variogram(voi ~ 1, loc = psu.sp, cutoff=cutoff.init, width=500)
  )
  # plot(v.psu, pl=T)
}
if (exists("landgis.sp")) {
  system.time(
    v.landgis <- variogram(voi ~ 1, loc = landgis.sp, cutoff=cutoff.init, width=500)
  )
  #  plot(v.landgis, pl=T)
}
```

Model the variograms with the exponential model; the range parameter is 1/3 of the effective range. Initial estimate of total sill is 80% of maximum semivariance of the empirical variogram; initial nugget is 0.

Note that these may not converge with the automatic initial model selection; if not, adjust by hand based on the plot of the empirical variogram (just above), or change the empirical variogram parameters.


```{r model.variogram, fig.height=6, fig.width=8}
vm.gnatsgo <- vgm(0.8*max(v.gnatsgo$gamma), "Exp", range.init, 0)
vmf.gnatsgo <- fit.variogram(v.gnatsgo, model=vm.gnatsgo)
# plot(v.gnatsgo, pl=T, model=vmf.gnatsgo)
#
vm.sg <- vgm(0.8*max(v.sg$gamma), "Exp", range.init, 0)
vmf.sg <- fit.variogram(v.sg, model=vm.sg)
# plot(v.sg, pl=T, model=vmf.sg)
#
if (exists("v.polaris")) {
  vm.polaris <- vgm(0.8*max(v.polaris$gamma), "Exp", range.init, 0)
  vmf.polaris <- fit.variogram(v.polaris, model=vm.polaris)
  # plot(v.polaris, pl=T, model=vmf.polaris)
}
if (exists("v.issr8")) {
  vm.issr8 <- vgm(0.8*max(v.issr8$gamma), "Exp", range.init, 0)
  vmf.issr8 <- fit.variogram(v.issr8, model=vm.issr8)
#  plot(v.issr8, pl=T, model=vmf.issr8)
}
if (exists("v.gsm")) {
  vm.gsm <- vgm(0.8*max(v.gsm$gamma), "Exp", range.init, 0)
  vmf.gsm <- fit.variogram(v.gsm, model=vm.gsm)
#  plot(v.gsm, pl=T, model=vmf.gsm)
}
if (exists("v.psu")) {
  vm.psu <- vgm(0.8*max(v.psu$gamma), "Exp", range.init, 0)
  vmf.psu <- fit.variogram(v.psu, model=vm.psu)
#  plot(v.psu, pl=T, model=vmf.psu)
}
if (exists("r.landgis")) {
  vm.landgis <- vgm(0.8*max(v.landgis$gamma), "Exp", range.init, 0)
  vmf.landgis <- fit.variogram(v.landgis, model=vm.landgis)
#  plot(v.landgis, pl=T, model=vmf.landgis)
}
```

## Table of variogram parameters

Make a table of the variogram parameters:

```{r table.compare.variograms}
vmeasure.compare <- data.frame(PSM_products = "", Range = 0, StructSill = 0, PropNugget = 0)
vmeasure.compare[1,] <- c("gNATSGO", 
                       round(vmf.gnatsgo[2,"range"], 0),
                       round(vmf.gnatsgo[2,"psill"], 2),
                       round(vmf.gnatsgo[1,"psill"]/sum(vmf.gnatsgo[,"psill"]), 2)
                       )
vmeasure.compare[2,] <- c("SG2", 
                       round(vmf.sg[2,"range"], 0),
                       round(vmf.sg[2,"psill"], 2),
                       round(vmf.sg[1,"psill"]/sum(vmf.sg[,"psill"]), 2)
                       )
i <- 2
if(exists("vmf.psu")) {
  vmeasure.compare[(i <- i+1), ] <-  c("SPCG", 
                       round(vmf.psu[2,"range"], 0),
                       round(vmf.psu[2,"psill"], 2),
                       round(vmf.psu[1,"psill"]/sum(vmf.psu[,"psill"]), 2))
}
if(exists("vmf.polaris")) {
  vmeasure.compare[(i <- i+1), ] <-  c("PSP", 
                       round(vmf.polaris[2,"range"], 0),
                       round(vmf.polaris[2,"psill"], 2),
                       round(vmf.polaris[1,"psill"]/sum(vmf.polaris[,"psill"]), 2))
}
if(exists("vmf.gsm")) {
  vmeasure.compare[(i <- i+1), ] <-  c("GSM v0.5", 
                       round(vmf.gsm[2,"range"], 0),
                       round(vmf.gsm[2,"psill"], 2),
                       round(vmf.gsm[1,"psill"]/sum(vmf.gsm[,"psill"]), 2))
}
if(exists("vmf.issr8")) {
  vmeasure.compare[(i <- i+1), ] <- c("ISSR-800", 
                       round(vmf.issr8[2,"range"], 0),
                       round(vmf.issr8[2,"psill"], 2),
                       round(vmf.issr8[1,"psill"]/sum(vmf.issr8[,"psill"]), 2))
}
if(exists("vmf.landgis")) {
  vmeasure.compare[(i <- i+1), ] <-  c("landgis", 
                       round(vmf.landgis[2,"range"], 0),
                       round(vmf.landgis[2,"psill"], 2),
                       round(vmf.landgis[1,"psill"]/sum(vmf.landgis[,"psill"]), 2))
}
# multiply all range parameters by 3 to get effective range
vmeasure.compare[, 2:4] <- apply(vmeasure.compare[, 2:4],  2, as.numeric)
vmeasure.compare[, "Range"] <- vmeasure.compare[, "Range"]*3
print(vmeasure.compare)
```


```{r write.table.compare.variograms}
names(vmeasure.compare) <- c("Product", "Effective range", 
                             "Structural Sill", "Proportional Nugget")
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(vmeasure.compare, row.names=FALSE, digits=2)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), file=
                 paste0("../LaTeX_tables/compare_variograms_",
                           AOI.dir.prefix, "_", voi.depth, ".tex"))
```

## Plot fitted variograms

Plot the variograms with the fitted models. 

A helper function:

```{r compute.position}
rc.pos <- function(r, c) {
  if (c == 0) { r <- r + 1; c <- 1} # go to the next row if this one is full
  return(c(r, c))
}
```

Plot:

```{r plot.vgms, fig.width=map.fig.width, fig.height=map.fig.height}
ylims <- c(0, max(v.gnatsgo$gamma, v.sg$gamma, 
                  ifelse(exists("v.gsm"), max(v.gsm$gamma), 0),
                  ifelse(exists("v.psu"), max(v.psu$gamma), 0),
                  ifelse(exists("v.polaris"), max(v.polaris$gamma), 0),
                  ifelse(exists("v.issr8"), max(v.issr8$gamma), 0),
                  ifelse(exists("v.landgis"), max(v.landgis$gamma), 0))*1.1)
p0 <- plot(v.gnatsgo, ylim=ylims, model=vmf.gnatsgo, main="gNATSGO", xlab="separation (m)", pch=20)
p1 <- plot(v.sg, ylim=ylims, model=vmf.sg, main="SG2", xlab="separation (m)", pch=20)
print(p0, split=c(1, 1, n.figs.col, n.figs.row), more=T) 
print(p1, split=c(2, 1, n.figs.col, n.figs.row), more=T) # for sure these two in the first row
r <- 1 ; c <- n.figs.col-2 # we used up two columns
if(exists("vmf.psu")) {
  pos <- rc.pos(r, c); r <- pos[1]; c <- pos[2]
  p2 <- plot(v.psu, ylim=ylims, model=vmf.psu, main="SPCG", xlab="separation (m)", pch=20)
  print(p2, split=c(c, r, n.figs.col, n.figs.row), more=T); c <- c + 1
} 
if(exists("vmf.polaris")) {
  pos <- rc.pos(r, c); r <- pos[1]; c <- pos[2]
  p3 <- plot(v.polaris, ylim=ylims, model=vmf.polaris, main="PSP", xlab="separation (m)", pch=20)
  print(p3, split=c(c, r, n.figs.col, n.figs.row), more=T); c <- c + 1
} 
if(exists("vmf.gsm")) {
  pos <- rc.pos(r, c); r <- pos[1]; c <- pos[2]
  p4 <- plot(v.gsm, ylim=ylims, model=vmf.gsm, main="GSM v0.5", xlab="separation (m)", pch=20)
  print(p4, split=c(c, r, n.figs.col, n.figs.row), more=T); c <- c + 1
} 
if(exists("vmf.issr8")) {
  pos <- rc.pos(r, c); r <- pos[1]; c <- pos[2]
  p5 <- plot(v.issr8, ylim=ylims, model=vmf.issr8, main="ISSR-800", xlab="separation (m)", pch=20)
  print(p5, split=c(c, r, n.figs.col, n.figs.row), more=T); c <- c + 1
} 
if(exists("vmf.landgis")) {
  pos <- rc.pos(r, c); r <- pos[1]; c <- pos[2]
  p6 <- plot(v.landgis, ylim=ylims, model=vmf.landgis, main="LandGIS", xlab="separation (m)", pch=20)
  print(p6, split=c(c, r, n.figs.col, n.figs.row), more=T); c <- c + 1
} 
print(NULL, split=c(c, r, n.figs.col, n.figs.row), more=F) # force the end of the figure
```


# Classify

The metrics used require classified maps, so we must classify into ranges. These can be of several types:

1. fixed, set by analyst. E.g., pH in 0.5 increments. These classes should have some application significance, e.g., limits in Soil Taxonomy or land capability systems.

2. "natural" classes from histograms or k-means,

In both cases using sharp class boundaries can lead to artefacts caused by the PSM method.

## Histogram equalization   

A better method is histogram equalization, with a user-defined number of classes. This avoids subjectivity and will work on any property.


```{r hist.equal.cuts, fig.width=8, fig.height=4}
n.class <- 8
#
# values.all computed above
values.all.sort <- sort(values.all)
#
n <- length(values.all) - sum(is.na(values.all))
(cut.positions <- round(n/n.class))
(cuts <- values.all.sort[cut.positions * 1:(n.class-1)])
hist(values.all, breaks=36, main="Histogram equalization")
abline(v=cuts, col="blue", lwd=2)
```


We set up a colour ramp that covers the entire range, and then select the colours out of it that match the actual value range.

```{r classify.setup}
(cut.names <- cut(zlim, breaks=c(zlim[1], cuts, zlim[2]),
                  ordered_result=TRUE, include.lowest = TRUE)) 
# make sure lowest value is included
#
# common colour ramp
color.ramp <- bpy.colors(n.class)
#
(class.limits <- c(zlim[1], cuts, zlim[2]))
```

Save the limits in a table for the paper:


```{r}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(data.frame(quantiles=c("minimum", paste0("q", 1:3), 
                                   "median", paste0("q", 5:7), "maximum"),
                       limits=round(class.limits,2)), 
            align="lrr",
            row.names=FALSE, digits=2)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), file=
                 paste0("../LaTeX_tables/class_limits_",
                           AOI.dir.prefix, "_", voi.depth, ".tex"))
```

## Classification

Reclassify according to the histogram-equalized limits.
Note that `terra::classify` keeps a record of the classification method, in this case, the vector of cutpoints, although the values of the reclassified raster are integer class numbers. These are found with `levels()[[1]]`.

```{r classify.raster}
gnatsgo.class <- classify(gnatsgo.crop, rcl=class.limits)
# gnatsgo.class <- as.factor(gnatsgo.class)
table(values(gnatsgo.class))
names(gnatsgo.class) <- "class"

# levels(gnatsgo.class) <- NULL # per Hijmans, removes category labels
# .l <- range(values(gnatsgo.class), na.rm=TRUE)
# terra::plot(gnatsgo.class,
#             col=color.ramp[.l[1]:.l[2]], type="classes",
#             main="SG2")
#
sg.class <- terra::classify(sg.crop, rcl=class.limits)
table(values(sg.class))
names(sg.class) <- "class"
# .l <- range(values(sg.class), na.rm=TRUE)
# terra::plot(sg.class,
#             col=color.ramp[.l[1]:.l[2]], type="classes",
#             main="SG2")
#
if (exists("gsm.crop")) {
  gsm.class <- classify(gsm.crop, rcl=class.limits)
  table(values(gsm.class))
  names(gsm.class) <- "class"
  # gsm.class <- as.factor(gsm.class)
  # .l <- range(values(gsm.class), na.rm=TRUE)
  # terra::plot(gsm.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="GSM")
  #
}
if (exists("issr8.crop")) {
  issr8.class <- classify(issr8.crop, rcl=class.limits)
  table(values(issr8.class))
  names(issr8.class) <- "class"
  # issr8.class <- as.factor(issr8.class)
  # .l <- range(values(issr8.class), na.rm=TRUE)
  # terra::plot(issr8.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="ISSR-800")
  #
}
if (exists("psu.crop")) {
  psu.class <- classify(psu.crop, rcl=class.limits)
  # psu.class <- as.factor(psu.class)
  table(values(psu.class))
  names(psu.class) <- "class"
  # .l <- range(values(psu.class), na.rm=TRUE)
  # terra::plot(psu.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="SPCG")
  #
}
if (exists("polaris.crop")) {
  polaris.class <- classify(polaris.crop, rcl=class.limits)
  # psu.class <- as.factor(psu.class)
  table(values(polaris.class))
  names(polaris.class) <- "class"
  # .l <- range(values(polaris.class), na.rm=TRUE)
  # terra::plot(polaris.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="PSP")
  #
}
if (exists("landgis.crop")) {
  landgis.class <- classify(landgis.crop, rcl=class.limits)
  # psu.class <- as.factor(psu.class)
  table(values(landgis.class))
  names(landgis.class) <- "class"
  # .l <- range(values(landgis.class), na.rm=TRUE)
  # terra::plot(landgis.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="LandGIS")
  #
}
```

```{r show.classified, fig.width=map.fig.width, fig.height=map.fig.height}
par(mfrow=c(n.figs.row, n.figs.col))
.l <- range(values(gnatsgo.class), na.rm=TRUE)
terra::plot(gnatsgo.class,
            col=color.ramp[.l[1]:.l[2]], type="classes",
            main="gNATSGO")
.l <- range(values(sg.class), na.rm=TRUE)
terra::plot(sg.class,
            col=color.ramp[.l[1]:.l[2]], type="classes",
            main="SG2")
if (exists("gsm.class")) {
  .l <- range(values(gsm.class), na.rm=TRUE)
  terra::plot(gsm.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="GSM")
}
if (exists("psu.class")) {
  .l <- range(values(psu.class), na.rm=TRUE)
  terra::plot(psu.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="SPCG")
}
if (exists("polaris.class")) {
  .l <- range(values(polaris.class), na.rm=TRUE)
  terra::plot(polaris.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="PSP")
}
if (exists("landgis.class")) {
  .l <- range(values(issr8.class), na.rm=TRUE)
  terra::plot(landgis.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="LandGIS")
}
if (exists("issr8.class")) {
  .l <- range(values(issr8.class), na.rm=TRUE)
  terra::plot(issr8.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="ISSR-800")
}
par(mfrow=c(1,1))
```

## Cross-classification

Cross-classification gNATSGO (rows) vs. SoilGrids250 (columns):

```{r xclass.1}
table(as.vector(gnatsgo.class), as.vector(sg.class),
      useNA = "ifany")
```

Cross-classification gNATSGO (rows) vs. SPCG100USA (columns):

```{r xclass.2}
if (exists("psu.class")) { 
  table(as.vector(gnatsgo.class), as.vector(psu.class),
      useNA = "ifany")
}
```

Cross-classification gNATSGO (rows) vs. POLARIS (columns):

```{r xclass.2a}
if (exists("polaris.class")) {
  table(as.vector(gnatsgo.class), as.vector(polaris.class),
      useNA = "ifany")
}
```

Cross-classification gNATSGO (rows) vs. LandGIS (columns):

```{r xclass.2b}
if (exists("landgis.class")) { 
  table(as.vector(gnatsgo.class), as.vector(landgis.class),
      useNA = "ifany")
}
```

Cross-classification SoilGrids250 (rows) vs. SPCG100USA (columns):

```{r xclass.3}
if (exists("psu.class")) { 
  table(as.vector(sg.class), as.vector(psu.class),
      useNA = "ifany")
}
```


## Polygonize

The V-metrics require polygon maps, not gridded maps of classes.

Polygonize them and adjust the class names.

```{r polygonize}
gnatsgo.poly <- terra::as.polygons(gnatsgo.class,
                                   values = TRUE,
                                   dissolve = TRUE)
# add break points and class IDs
gnatsgo.poly$breaks <- cuts[-1]
gnatsgo.poly$class <- 1:n.class

sg.poly <- terra::as.polygons(sg.class,
                              values = TRUE, 
                              dissolve=TRUE)
sg.poly$breaks <- cuts[-1]
sg.poly$class <- 1:n.class

if (exists("issr8.class")) {
  issr8.poly <- terra::as.polygons(issr8.class, 
                                   values = TRUE,
                                   dissolve=TRUE)
  issr8.poly$breaks <- cuts[-1]
  issr8.poly$class <- 1:n.class
}
if (exists("psu.class")) {
  psu.poly <- terra::as.polygons(psu.class, 
                                 values = TRUE,dissolve=TRUE)
  psu.poly$breaks <- cuts[-1]
  psu.poly$class <- 1:n.class
}  
if (exists("polaris.class")) {
  polaris.poly <- terra::as.polygons(polaris.class, 
                                 values = TRUE,dissolve=TRUE)
  polaris.poly$breaks <- cuts[-1]
  polaris.poly$class <- 1:n.class
}  
 if (exists("landgis.class")) {
  landgis.poly <- terra::as.polygons(landgis.class, 
                                 values = TRUE,dissolve=TRUE)
  landgis.poly$breaks <- cuts[-1]
  landgis.poly$class <- 1:n.class
}  
```

## Simple Features

Some of the methods require Simple Features representation of spatial objects.

Convert the `terra::SpatVector` objects to Simple Features. 

```{r convert.polygons.sf}
#
gnatsgo.sf <- st_as_sf(gnatsgo.poly)
#
sg.sf <- st_as_sf(sg.poly)
#
if (exists("gsm.class")) { 
  gsm.sf <- st_as_sf(gsm.poly)
}
#
if (exists("psu.class")) {
  psu.sf <- st_as_sf(psu.poly)
}
#
if (exists("polaris.class")) {
  polaris.sf <- st_as_sf(polaris.poly)
}
#
if (exists("issr8.class")) { 
  issr8.sf <- st_as_sf(issr8.poly)
}
if (exists("landgis.class")) {
  landgis.sf <- st_as_sf(landgis.poly)
}
#
```

## Topology

The topology is not correct, so `vmeasure_calc` throws an error. Clean up the topology with `sf::st_make_valid`.

See https://www.r-spatial.org/r/2017/03/19/invalid.html. 

```{r}
# st_is_valid(gnatsgo.sf, reason=TRUE)
gnatsgo.sf.v <- sf::st_make_valid(gnatsgo.sf)
# st_is_valid(gnatsgo.sf.v, reason=TRUE)
#
# st_is_valid(sg.sf, reason=TRUE)
sg.sf.v <- sf::st_make_valid(sg.sf)
# st_is_valid(sg.sf.v, reason=TRUE)
if (exists("gsm.sf")) {
  st_is_valid(gsm.sf, reason=TRUE)
  gsm.sf.v <- sf::st_make_valid(gsm.sf)
  # st_is_valid(gsm.sf.v, reason=TRUE)
}
if (exists("issr8.sf")) {
  st_is_valid(issr8.sf, reason=TRUE)
  issr8.sf.v <- sf::st_make_valid(issr8.sf)
  # st_is_valid(issr8.sf.v, reason=TRUE)
}
if (exists("psu.sf")) {
  st_is_valid(psu.sf, reason=TRUE)
  psu.sf.v <- sf::st_make_valid(psu.sf)
  # st_is_valid(psu.sf.v, reason=TRUE)
}
if (exists("polaris.sf")) {
  st_is_valid(polaris.sf, reason=TRUE)
  polaris.sf.v <- sf::st_make_valid(polaris.sf)
  # st_is_valid(polaris.sf.v, reason=TRUE)
}
if (exists("landgis.sf")) {
  st_is_valid(landgis.sf, reason=TRUE)
  landgis.sf.v <- sf::st_make_valid(landgis.sf)
  # st_is_valid(landgis.sf.v, reason=TRUE)
}
```


Now the topology is correct.

## Plot the polygonized class maps

Display the maps. Compute each legend from the classes present in that map.

```{r make_class_maps}
my.pal <- brewer.pal(n.class, "PuBu")  # safe for colour-blind viewers
l.gnatsgo <- range(gnatsgo.sf.v$class, na.rm = TRUE)
l.sg <- range(sg.sf.v$class, na.rm = TRUE)
if (exists("gsm.sf")) { l.gsm <- range(gsm.sf.v$class, na.rm = TRUE) }
if (exists("issr8.sf")) { l.issr8 <- range(issr8.sf.v$class, na.rm = TRUE) }
if (exists("psu.sf")) { l.psu <- range(psu.sf.v$class, na.rm = TRUE) }
if (exists("polaris.sf")) { l.polaris <- range(polaris.sf.v$class, na.rm = TRUE) }
if (exists("landgis.sf")) { l.landgis <- range(landgis.sf.v$class, na.rm = TRUE) }
g0 <- ggplot(data=gnatsgo.sf.v) +
  geom_sf(aes(fill = class)) +
  coord_sf(crs = st_crs(gnatsgo.sf)) +
#  guides(fill=FALSE) +   # no legend on the two leftmost
# no, that distorts the size compared to the one with legend
   labs(title = "gNATSGO")  +
  scale_fill_continuous(low=my.pal[l.gnatsgo[1]], high=my.pal[l.gnatsgo[2]]) +
  theme(legend.position = "bottom", legend.direction = "horizontal")
g1 <- ggplot(data=sg.sf.v) +
  geom_sf(aes(fill = class)) +
  coord_sf(crs = st_crs(sg.sf)) +
  labs(title = "SG2")  +
  scale_fill_continuous(low=my.pal[l.sg[1]], high=my.pal[l.sg[2]]) +
  theme(legend.position = "bottom", legend.direction = "horizontal")
if (exists("gsm.sf")) { 
  g2 <- ggplot(data=gsm.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "GSM v0.5")  +
    scale_fill_continuous(low=my.pal[l.gsm[1]], high=my.pal[l.gsm[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
if (exists("issr8.sf")) { 
  g3 <- ggplot(data=issr8.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "ISSR-800")  +
    scale_fill_continuous(low=my.pal[l.issr8[1]], high=my.pal[l.issr8[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
if (exists("psu.sf")) { 
  g4 <- ggplot(data=psu.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "SPCG") +
    scale_fill_continuous(low=my.pal[l.psu[1]], high=my.pal[l.psu[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
if (exists("polaris.sf")) { 
  g5 <- ggplot(data=polaris.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "PSP") +
    scale_fill_continuous(low=my.pal[l.polaris[1]], high=my.pal[l.polaris[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
if (exists("landgis.sf")) { 
  g6 <- ggplot(data=landgis.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "LandGIS") +
    scale_fill_continuous(low=my.pal[l.landgis[1]], high=my.pal[l.landgis[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
```

Show the class maps:

```{r class_maps, fig.width=map.fig.width, fig.height=map.fig.height}
tmp <- "list(g0, g1"
if (exists("g2")) { tmp <- paste0(tmp, ", g2") }
if (exists("g3")) { tmp <- paste0(tmp, ", g3") }
if (exists("g4")) { tmp <- paste0(tmp, ", g4") }
if (exists("g5")) { tmp <- paste0(tmp, ", g5") }
if (exists("g6")) { tmp <- paste0(tmp, ", g6") }
tmp <- paste0(tmp, ")")
grid.arrange(grobs = eval(parse(text=tmp)), nrow=n.figs.row, ncol=n.figs.col)
```



# Metrics from the `sabre` package

These metrics are explained in:

Nowosad, J., & Stepinski, T. F. (2018). Spatial association between regionalizations using the information-theoretical V-measure. International Journal of Geographical Information Science, 32(12), 2386–2401. https://doi.org/10.1080/13658816.2018.1511794

and implemented in the `sabre` package:

## V metrics {#vmetrics}

The _V-measure_ originated in the field of computer science as a measure for comparison of different clusterings of the same domain.  It is a measure of an overall spatial correspondence between classified maps -- these are analogous to clusterings. So continuous maps (as in this study) must be classified into the same classes, and the two classified maps then compared.

"The V-measure method has several advantages over the widely used Mapcurves method, it has clear interpretations in terms of mutual information as well as in terms of analysis of variance, 

_Homogeneity_ shows an average homogeneity of the regions in the 2nd map with respect to the regions in the 1st, i.e., how close the 2nd map comes to reproducing the 1st

_Completeness_ is a function of homogeneity of the regions in the 1st map with respect to the regions in the 2nd, i.e., how much the regions in the 1st map reproduce those of the 2nd 
These do not depend on the class labels, only on the number/quantity of regions (classes) in the source map compared to given region of the target map. 

This function uses the `sf::st_intersection()`,m which depends on the coordinates values precision.
(For example, precision = 1000 rounds values to the third decimal places and precision = 0.001
uses values rounded to the nearest 1000, see `sf::st_as_binary`).



The `vmeasure_calc()` function calculates intersections of the input geometries.
For this function we must specify the names of the columns with the region names; both x and y must contain `POLYGON`s or `MULTIPOLYGON`s and have the same CRS. 



## Compute metrics

Compute the metrics with the `sabre` package. The first-listed map is the map to evaluate, with respect to the second-listed (reference) map.

### gNATSGO vs. SoilGrids

```{r gNATSGO8.sg}
regions.gnatsgo.sg <- vmeasure_calc(x = gnatsgo.sf.v, 
                                 y = sg.sf.v, 
                                 x_name = class, y_name = class)
class(regions.gnatsgo.sg) 
print(regions.gnatsgo.sg)
names(regions.gnatsgo.sg)
names(regions.gnatsgo.sg$map1)
```

`rih` is the intersection map. Show these:

Geometric precision is set by `st_as_binary`, default is `attr(x, "precision")`. Here we didn't change it and the intersection looks good.

```{r}
attr(regions.gnatsgo.sg, "precision")  # NULL, means a system default
```

Here we leave it as the default `NULL`.

```{r vmaps.gnatsgo.sg, fig.width=4, fig.height=6}
  ## produced maps -- the homogeneity of the regions.gnatsgo.sg
terra::plot(regions.gnatsgo.sg$map1["rih"], main = "Inhomogeneity -- SG2 vs. gNATSGO")
terra::plot(regions.gnatsgo.sg$map2["rih"], main = "Incompleteness -- SG2 vs. gNATSGO")
```

### gNATSGO vs. SPCG100USA

```{r vmaps.gnatsgo.psu, fig.width=4, fig.height=6}
if (exists("psu.sf.v")) {
  regions.gnatsgo.psu <- vmeasure_calc(x = gnatsgo.sf.v, 
                                       y = psu.sf.v, 
                                       x_name = class, y_name = class)
  class(regions.gnatsgo.psu) 
  print(regions.gnatsgo.psu)
  names(regions.gnatsgo.psu)
  names(regions.gnatsgo.psu$map1)
  ## produced maps -- the homogeneity of the regions.gnatsgo.psu
  terra::plot(regions.gnatsgo.psu$map1["rih"], main = "Inhomogeneity -- SPCG vs. gNATSGO")
  terra::plot(regions.gnatsgo.psu$map2["rih"], main = "Incompleteness -- SPCGA vs. gNATSGO")
}
```


### gNATSGO vs. POLARIS

```{r vmaps.gnatsgo.polaris, fig.width=4, fig.height=6}
par(mfrow=c(1, 2))
regions.gnatsgo.polaris <- vmeasure_calc(x = gnatsgo.sf.v, 
                                      y = polaris.sf.v, 
                                      x_name = class, y_name = class)
class(regions.gnatsgo.polaris) 
print(regions.gnatsgo.polaris)
names(regions.gnatsgo.polaris)
names(regions.gnatsgo.polaris$map1)
terra::plot(regions.gnatsgo.psu$map1["rih"], main = "Inhomogeneity -- PSP vs. gNATSGO")
terra::plot(regions.gnatsgo.psu$map2["rih"], main = "Incompleteness -- PSP vs. gNATSGO")
```

### SPCG100USA vs. SoilGrids250

```{r vmaps.psu.sg, fig.width=4, fig.height=6}
if (exists("psu.sf.v")) {
  regions.psu.sg <- vmeasure_calc(x = psu.sf.v, 
                                  y = sg.sf.v, 
                                  x_name = class, y_name = class)
  class(regions.psu.sg) 
  print(regions.psu.sg)
  names(regions.psu.sg)
  names(regions.psu.sg$map1)
  ## produced maps -- the homogeneity of the regions
  terra::plot(regions.psu.sg$map1["rih"], main = "Inhomogeneity -- SPCG vs. SG2")
  terra::plot(regions.psu.sg$map2["rih"], main = "Incompleteness -- SPCG vs. SG2")
}
```

## Table with `vmeasure` statistics

```{r}
str(regions.gnatsgo.sg, max.level = 1)
vmeasure.compare <- data.frame(PSM_products = "", V_measure = 0, Homogeneity = 0, Completeness = 0)
vmeasure.compare[1,] <- c("gNATSGO vs. SG2", 
                       round(regions.gnatsgo.sg$v_measure, 4),
                       round(regions.gnatsgo.sg$homogeneity, 4),
                       round(regions.gnatsgo.sg$completeness, 4)
                       )
i <- 1
if (exists("regions.gnatsgo.psu")) {
  vmeasure.compare[i <- i+1,] <- c("gNATSGO vs. SPCG", 
                            round(regions.gnatsgo.psu$v_measure, 4),
                            round(regions.gnatsgo.psu$homogeneity, 4),
                            round(regions.gnatsgo.psu$completeness, 4)
  )
}
if (exists("regions.gnatsgo.polaris")) {
  vmeasure.compare[i <- i+1,] <- c("gNATSGO vs. PSP", 
                            round(regions.gnatsgo.polaris$v_measure, 4),
                            round(regions.gnatsgo.polaris$homogeneity, 4),
                            round(regions.gnatsgo.polaris$completeness, 4)
  )
}
if (exists("regions.gnatsgo.psu")) {
  vmeasure.compare[i <- i+1,] <- c("SPCG vs. SG2", 
                       round(regions.psu.sg$v_measure, 4),
                       round(regions.psu.sg$homogeneity, 4),
                       round(regions.psu.sg$completeness, 4)
                       )
  
}
print(vmeasure.compare)
```

Save for paper:


```{r}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(vmeasure.compare, row.names=FALSE, digits=2)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), file=
                 paste0("../LaTeX_tables/compare_vmeasure_",
                           AOI.dir.prefix, "_", voi.depth, ".tex"))
```


# Landscape metrics (`landscapemetrics` package) {#landscapemetrics}

This package implements a set of metrics as used in ecology and derived from the FRAGSTATS computer program.

Package: https://r-spatialecology.github.io/landscapemetrics/index.html

Reference: Hesselbarth, M. H. K., Sciaini, M., With, K. A., Wiegand, K., & Nowosad, J. (2019). landscapemetrics: An open-source R tool to calculate landscape metrics. Ecography, 42, 1648–1657. https://doi.org/10.1111/ecog.04617

## Convert to `raster`

These packages work with `raster` objects, so convert from `terra` structures.

```{r}
r.gnatsgo <- raster(gnatsgo.class)
r.sg <- raster(sg.class)
if (exists("gsm.class")) r.gsm <- raster(gsm.class)
if (exists("issr8.class")) r.issr8 <- raster(issr8.class)
if (exists("psu.class")) r.psu <- raster(psu.class)
if (exists("polaris.class")) r.polaris <- raster(polaris.class)
if (exists("landgis.class")) r.landgis <- raster(landgis.class)
```

"The first step of every analysis should be a check if the input raster is suitable for `landscapemetrics` using `check_landscape()`. The function checks if the coordinate reference system is projected, if the cell units are in meters, if the classes are decoded as integer values, and if the number of different values is reasonable (in other words if discrete land‐cover classes are present). In case the input is not or only partially suitable, a corresponding warning is produced. This means that a calculation of metrics is still possible, but some results must be interpreted with caution (e.g. area‐ and distance‐related metrics)."

Check them:

```{r check.landscape}
check_landscape(r.gnatsgo)
check_landscape(r.sg)
if (exists("gsm.class")) check_landscape(r.gsm)
if (exists("issr8.class")) check_landscape(r.issr8)
if (exists("psu.class")) check_landscape(r.psu)
if (exists("polaris.class")) check_landscape(r.polaris)
if (exists("landgis.class")) check_landscape(r.landgis)
```


A function to display the landscape with a consistent colour ramp:

```{r show.landscape.function}
(my.pal <- c(brewer.pal(n.class, "RdYlGn"), "#FFFFFF"))
show.landscape <- function(r.map, r.title) {
  check_landscape(r.map)
  g <- show_landscape(r.map, discrete = TRUE) +
    theme(legend.position = "bottom",
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          legend.title = element_blank()) +
    labs(title = r.title)
  return(g)
}
```

Show the landscapes of each product:

```{r show.landscape, fig.width=7, fig.height=5}
(g <- show.landscape(r.gnatsgo, "gNATSGO"))
(g <- show.landscape(r.sg, "SoilGrids250"))
if (exists("r.psu")) (g <- show.landscape(r.psu, "SPCG"))
if (exists("r.polaris")) (g <- show.landscape(r.polaris, "PSP"))
if (exists("r.landgis")) (g <- show.landscape(r.landgis, "LandGIS"))
if (exists("r.gsm")) (g <- show.landscape(r.gsm, "GSM v0.5"))
if (exists("r.issr8")) (g <- show.landscape(r.issr8, "ISSR-800"))
```



## Metrics list

"All functions in `landscapemetrics` start with `lsm_`. The second part of the name specifies the level (patch - `p`, class - `c` or landscape - `l`). The last part of the function name is the abbreviation of the corresponding metric (e.g. `enn` for the euclidean nearest-neighbor distance)."

Here are all the landscape-level metrics:

```{r}
list_lsm(level="landscape") %>% print(n=Inf)
ls.metrics <- calculate_lsm(r.sg, level = "landscape")
(ls.metrics) %>% print(n=16)
data.frame(ls.metrics)
```

All the class-level metrics, applied to SoilGrids250:

```{r}
list_lsm(level="class")  %>% print(n=Inf)
class.metrics <- calculate_lsm(r.sg, level = "class")
(class.metrics)
```

All the patch-level metrics, applied to SoilGrids250:

```{r}
list_lsm(level="patch")  %>% print(n=Inf)
patch.metrics <- calculate_lsm(r.sg, level = "patch")
(patch.metrics)
```



## Visualize class and patch metrics

Core areas for each _class_. These are the "typical" areas, used mainly for habitats. Here they show where the class is concentrated. Here we just show gNATSGO as an example, these are not further used.

```{r show.core.areas, fig.width=12, fig.height=12}
show_cores(r.gnatsgo)
# show_cores(r.sg)
# if (exists("r.gsm")) show_cores(r.gsm)
# if (exists("r.issr8")) show_cores(r.issr8)
# if (exists("r.psu")) show_cores(r.psu)
# if (exists("r.polaris")) show_cores(r.polaris)
# if (exists("r.landgis")) show_cores(r.landgis)
```

Show the landscape with a patch-level metric in each _patch_. For example, the contiguity of each patch of the gNATSGO class map:

```{r show.patch.level.metrics, fig.width=4, fig.height=5}
show_lsm(r.gnatsgo, what="lsm_p_contig")
# show_lsm(r.sg, what="lsm_p_contig")
# if (exists("r.gsm")) show_lsm(r.gsm, what="lsm_p_contig")
# if (exists("r.issr8")) show_lsm(r.issr8, what="lsm_p_contig")
# if (exists("r.psu")) show_lsm(r.psu, what="lsm_p_contig")
# if (exists("r.polaris")) show_lsm(r.polaris, what="lsm_p_contig")
# if (exists("r.landgis")) show_lsm(r.landgis, what="lsm_p_contig")
```

But we want landscape-level metrics, we are not interested in individual patches.

## Table of landscape metrics

Here are the landscape-level metrics we will report:

```{r}
lst <- paste0("lsm_l_", c("shdi", "shei", "lsi", "ai",  "frac_mn"))
ls.metrics.gnatsgo <- calculate_lsm(r.gnatsgo, what=lst)
ls.metrics.sg <- calculate_lsm(r.sg, what=lst)
if(exists("r.psu")) ls.metrics.psu <- calculate_lsm(r.psu, what=lst)
if(exists("r.polaris")) ls.metrics.polaris <- calculate_lsm(r.polaris, what=lst)
if(exists("r.gsm")) ls.metrics.gsm <- calculate_lsm(r.gsm, what=lst)
if(exists("r.issr8")) ls.metrics.issr8 <- calculate_lsm(r.issr8, what=lst)
if(exists("r.landgis")) ls.metrics.landgis <- calculate_lsm(r.landgis, what=lst)
```

Make a table with the metrics for the several products.

```{r}
metrics.table <- data.frame(product=c("gNATSGO", "SG2"),
                            rbind(round(ls.metrics.gnatsgo$value, 3),
                                  round(ls.metrics.sg$value, 3)))
if (exists("ls.metrics.psu")) { metrics.table <- rbind(metrics.table, 
                                                       c("SPCG", round(ls.metrics.psu$value, 3))) }  
if (exists("ls.metrics.polaris")) { metrics.table <- rbind(metrics.table, 
                                                           c("PSP", round(ls.metrics.polaris$value, 3))) }  
if (exists("ls.metrics.gsm")) { metrics.table <- rbind(metrics.table, 
                                                       c("GSM v0.5", round(ls.metrics.gsm$value, 3))) }  
if (exists("ls.metrics.issr8")) { metrics.table <- rbind(metrics.table, 
                                                         c("ISSR-800", round(ls.metrics.issr8$value, 3))) }  
if (exists("ls.metrics.landgis")) { metrics.table <- rbind(metrics.table, 
                                                           c("LandGIS", round(ls.metrics.landgis$value, 3))) }  
names(metrics.table)[2:6] <- ls.metrics.gnatsgo$metric
```


```{r metrics.table}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(metrics.table, row.names=FALSE, digits=3)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), file=
                 paste0("../LaTeX_tables/landscape_metrics_",
                           AOI.dir.prefix, "_", voi.depth, ".tex"))
```


# Distance between co-occurrence vectors

Generate a "signature" of the landscapes, in this case, the co-occurrence vector:

```{r metrics.cove}
library(motif) # `lsp_signature`
library(stars) # `motif` functions require this format
# normalized co-occurence vector 8 x 8
# plot(st_as_stars(r.sg))
# plot(st_as_stars(r.gnatsgo))
#
cove.sg <- lsp_signature(st_as_stars(r.sg), type="cove")
cove.gnatsgo <- lsp_signature(st_as_stars(r.gnatsgo), type="cove")
if (exists("r.psu")) cove.psu <- lsp_signature(st_as_stars(r.psu), type="cove")
if (exists("r.polaris")) cove.polaris <- lsp_signature(st_as_stars(r.polaris), type="cove")
if (exists("r.gsm")) cove.gsm <- lsp_signature(st_as_stars(r.gsm), type="cove")
if (exists("r.issr8")) cove.issr8 <- lsp_signature(st_as_stars(r.issr8), type="cove")
if (exists("r.landgis")) cove.landgis <- lsp_signature(st_as_stars(r.landgis), type="cove")
```

Compute the Jensen-Shannon distances between signatures:

```{r distance.cove}
# combine the vectors into a dataframe, one row per vector
cove.df <- data.frame(cove.gnatsgo)$signature[[1]][1,]
cove.df <- rbind(cove.df, cove.sg$signature[[1]][1,])
df.row.names <- c( "gNATSGO", "SG2")
if (exists("r.psu")) {
  cove.df <- rbind(cove.df, cove.psu$signature[[1]][1,])
  df.row.names <- c(df.row.names, "SPCG")
}
if (exists("r.polaris")) {
  cove.df <- rbind(cove.df, cove.polaris$signature[[1]][1,])
  df.row.names <- c(df.row.names, "PSP")
}
if (exists("r.gsm")) {
  cove.df <- rbind(cove.df, cove.gsm$signature[[1]][1,])
  df.row.names <- c(df.row.names, "GSM v0.5")
}
if (exists("r.issr8")) {
  cove.df <- rbind(cove.df, cove.issr8$signature[[1]][1,])
  df.row.names <- c(df.row.names, "ISSR8")
}
if (exists("r.landgis")) {
  cove.df <- rbind(cove.df, cove.landgis$signature[[1]][1,])
  df.row.names <- c(df.row.names, "LandGIS")
}
row.names(cove.df) <- df.row.names
# compute the distances
#
# philentropy::getDistMethods()
cove.dists <- round(
  philentropy::distance(cove.df, method = "jensen-shannon", 
                        use.row.names =TRUE, 
                        as.dist.obj = FALSE,
                        diag = FALSE)
  ,4)
print(cove.dists)
```   

Export the results to a \LaTex{} table:

```{r table.cove}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(as.matrix(cove.dists), row.names=TRUE, digits=3)
autoformat(x)
capture.output(print(x, include.rownames=TRUE), file=
                 paste0("../LaTeX_tables/compare_landscape_patterns_",
                           AOI.dir.prefix, "_", voi.depth, ".tex"))
```


