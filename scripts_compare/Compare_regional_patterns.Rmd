---
title: "Comparing spatial patterns of PSM mapsat regional resolution"
author:
- D G Rossiter
- d.g.rossiter@cornell.edu
date: "`r format(Sys.Date(), '%d-%B-%Y')`"
output:
  html_document:
    fig_align: center
    fig_height: 5
    fig_width: 10
    number_section: yes
    theme: spacelab
    df_print: paged
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.align = 'center', fig.path = './figs/cf_maps/')
knitr::opts_chunk$set(cache.extra = R.version.string)
```

# Objective

Quantify the *spatial* agreement between soil maps, using several methods: (1) ["V metrics"](#vmetrics) (2) [Landscape metrics](#landscapemetrics) similar to FRAGSTATS, as used in ecology.

Here we compare:

* [SoiLGrids250](https://www.isric.org/explore/soilgrids)  from ISRIC further abbreviated as _SG2_;
* [Global Soil Map v0.5 for the USA](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/research/?cid=nrcseprd1321715), further abbreviated as _GSMv05_;
* [Intermediate-scale gridded soil property and interpretation maps from averaged and aggregated SSURGO and STATSGO data](https://github.com/ncss-tech/ISSR-800), further abbreviated as _ISSR-800_;
* POLARIS Soil Properties;
* [Soil Properties and Class 100m Grids USA](https://doi.org/10.18113/S1KW2H), further abbreviated as _SPCG100USA_;
* [LandGIS](https://opengeohub.org/about-landgis) from the private company [EnvirometriX](http://envirometrix.nl/).


This script must follow script `Compare_regional.Rmd` "Comparing PSM products at regional resolution". That script harmonizes the area of interest and resolution of these sources.

# Packages

```{r}
library(raster, warn.conflicts=FALSE)      # previous version of raster classes now in `terra`
                     #   needed for landscape metrics
library(terra, warn.conflicts=FALSE)       # Robert Hijmans raster and vector data
library(rgdal)       # CRS
library(sp)          # `sp` spatial classes
library(sf)          # Simple Features
require(xtable)      # format tables for LaTeX
library(dplyr)       # data wrangling
library(ggplot2)     # ggplot graphics
library(gridExtra)
library(RColorBrewer)
library(sabre)       # compare polygon map spatial structure
library(landscapemetrics)   # FRAGSTATS metrics
library(landscapetools)
library(gstat)      # variogram modelling
```

# Local storage

Set the directory on the local file system, under which local files were stored by `Compare_regional.Rmd`, and where this script will store its results.

```{r}
base.dir <- "/Users/rossiter/ds/Compare_PSM/"
```

# Area, property and depth to compare

Set part of a file path using the AOI and property to be compared.
These names correspond to files stored by script `Compare_regional.Rmd`, which incorporate the AOI `aoi` and the property of interest and depth slice `voi`.

AOI:

```{r aoi}
tile.lrc <- c(-76, 42)   # lower-right corner
tile.size <- 1
tile.ulc <- c(tile.lrc[1]-tile.size, tile.lrc[2]+tile.size) # upper-left corner
aoi <- paste0("lat", tile.lrc[2], tile.ulc[2],
                         "_lon", tile.ulc[1], tile.lrc[1])
```


Property of interest:

```{r voi}
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.n <- 4
voi.sg <- voi.list.sg[voi.n]
```

Depth slice:

```{r depth}
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.n <- 1
```


```{r voi.depth.sg}
voi.depth <- paste0(voi.sg, "_", depth.list.sg[depth.n])
```

# Source rasters

The maps from SG2, SPCG100USA and POLARIS were upscaled to 800 m, to match ISSR800 (reference, considered the most correct)  These were saved in script `ISSR800_compare_all.Rmd`.

Load the rasters and name the data item generically, so it can be used in expressions.

```{r}
(gsm <- rast(paste0(base.dir, aoi, "/gsm_tile_250_", voi.depth, ".tif")))
names(gsm) <- "voi"
(sg <- rast(paste0(base.dir, aoi, "/sg_tile_250_", voi.depth, ".tif")))
names(sg) <- "voi"
file.name <- paste0(base.dir, aoi, "/issr8_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (issr8 <- rast(file.name)); names(issr8) <- "voi" }
file.name <- paste0(base.dir, aoi, "/psu_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (psu <- rast(file.name)); names(psu) <- "voi" }
file.name <- paste0(base.dir, aoi, "/polaris_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (polaris <- rast(file.name)); names(polaris) <- "voi" }
file.name <- paste0(base.dir, aoi, "/landgis_tile_250_", voi.depth, ".tif")
if (file.exists(file.name)) { (landgis <- rast(file.name)); names(landgis) <- "voi" }
rgdal::showP4(crs(sg))
```

These are all in WGS84 geographic coordinates, cover the same area, and have the same no-data areas.


## Test area

Test on small part, 40 x 40 km:

```{r crop.test.area}
test.tile.size <- 0.2  # degrees
test.tile.x.offset <- 0.2  # west from right edge
test.tile.y.offset <- 0.7  # north from bottom edge
(tmp <- as.vector(ext(sg)))
tmp["xmax"] <- tmp["xmax"] - test.tile.x.offset
tmp["xmin"] <- tmp["xmax"] - test.tile.size
tmp["ymin"] <- tmp["ymin"] + test.tile.y.offset
tmp["ymax"] <- tmp["ymin"] + test.tile.size
ext(tmp)
sg.crop <- crop(sg, ext(tmp))
gsm.crop <- crop(gsm, ext(tmp))
if (exists("issr8")) { issr8.crop <- crop(issr8, ext(tmp)) }
if (exists("psu")) { psu.crop <- crop(psu, ext(tmp)) }
if (exists("polaris")) { polaris.crop <- crop(polaris, ext(tmp)) }
if (exists("landgis")) { landgis.crop <- crop(landgis, ext(tmp)) }
```

Determine the full range of the property across all maps, to one decimal place:

```{r zlim}
zlim <- c(floor(min(values(sg.crop)*10,
                    values(gsm.crop)*10,
                    ifelse(exists("issr8.crop"), values(issr8.crop)*10, NA),
                    ifelse(exists("psu.crop"), values(psu.crop)*10, NA),
                    ifelse(exists("polaris.crop"), values(polaris.crop)*10, NA),
                    ifelse(exists("landgis.crop"), values(landgis.crop)*10, NA),
                    na.rm=TRUE)),
          ceiling(max(values(sg.crop)*10,
                      values(gsm.crop)*10, 
                      ifelse(exists("issr8.crop"), values(issr8.crop)*10,  NA),
                      ifelse(exists("psu.crop"), values(psu.crop)*10, NA),
                      ifelse(exists("polaris.crop"), values(polaris.crop)*10, NA),
                      ifelse(exists("landgis.crop"), values(landgis.crop)*10, NA),
                      na.rm=TRUE)))/10
print(zlim)
```

Now show the maps together:

```{r side.by.side, fig.width=12, fig.height=18}
par(mfrow=c(3,2))
plot(gsm.crop, main="GSM v0.5", range=zlim)
plot(sg.crop, main="SoilGrids250", range=zlim)
if (exists("psu.crop")) plot(psu.crop, main="SPCG100USA", range=zlim)
if (exists("polaris.crop")) plot(polaris.crop, main="POLARIS", range=zlim)
if (exists("landgis.crop")) plot(landgis.crop, main="LandGIS", range=zlim)
if (exists("issr8.crop")) plot(issr8.crop, main="ISSR-800", range=zlim)
par(mfrow=c(1,1))
```   


## Statistical differences (non-spatial)

```{r}
rmse <- function(v1, v2) {
  round(sqrt(mean((v1-v2)^2, na.rm=TRUE)),3)
}
me <- function(v1, v2) { 
  round(mean(v1-v2, na.rm=TRUE), 3)
}
rmse.adj <- function(v1, v2) {   # RMSE adjusted for ME (bias)
  me <- mean(v1-v2, na.rm=TRUE)
  v2.adj <- v2 + me
  round(sqrt(mean((v1-v2.adj)^2, na.rm=TRUE)),3)
}
```

```{r}
stats.compare <- data.frame(PSM_product = "", MD = 0, RMSD = 0, RMSD.Adjusted = 0)
stats.compare[1, ] <- c("SoilGrids250",
                        me(values(gsm.crop),values(sg.crop)),
                        rmse(values(gsm.crop),values(sg.crop)),
                        rmse.adj(values(gsm.crop),values(sg.crop))
                        )
if (exists("psu.crop")) stats.compare[2, ] <- c("SPCG100USA",
                        me(values(gsm.crop),values(psu.crop)),
                        rmse(values(gsm.crop),values(psu.crop)),
                        rmse.adj(values(gsm.crop),values(psu.crop))
                        )
if (exists("polaris.crop")) stats.compare[3, ] <- c("POLARIS",
                        me(values(gsm.crop),values(polaris.crop)),
                        rmse(values(gsm.crop),values(polaris.crop)),
                        rmse.adj(values(gsm.crop),values(polaris.crop))
                        )
if (exists("landgis.crop")) stats.compare[4, ] <- c("POLARIS",
                        me(values(gsm.crop),values(landgis.crop)),
                        rmse(values(gsm.crop),values(landgis.crop)),
                        rmse.adj(values(gsm.crop),values(landgis.crop))
                        )
if (exists("issr8.crop")) stats.compare[5, ] <- c("POLARIS",
                        me(values(gsm.crop),values(issr8.crop)),
                        rmse(values(gsm.crop),values(issr8.crop)),
                        rmse.adj(values(gsm.crop),values(issr8.crop))
                        )
print(stats.compare)
```

Any bias in the three will affect the cross-classification and spatial statistics. 

So also make a bias-adjusted version of the PSM products, using GSM as the basis.

## Adjust for bias (systematic error)


```{r side.by.side.unbiased, fig.width=12, fig.height=12}
sg.adj <- sg.crop + me(values(gsm.crop),values(sg.crop))
if (exists("psu.crop")) psu.adj <- psu.crop + me(values(gsm.crop),values(psu.crop))
if (exists("polaris.crop")) polaris.adj <- polaris.crop + me(values(gsm.crop),values(polaris.crop))
if (exists("landgis.crop")) landgis.adj <- landgis.crop + me(values(gsm.crop),values(landgis.crop))
if (exists("issr8.crop")) issr8.adj <- issr8.crop + me(values(gsm.crop),values(issr8.crop))
```

Recompute limits:

```{r zlim.adj}
zlim.adj <- c(floor(min(values(sg.adj)*10,
                    values(gsm.crop)*10,
                    ifelse(exists("issr8.adj"), values(issr8.adj)*10, NA),
                    ifelse(exists("psu.adj"), values(psu.adj)*10, NA),
                    ifelse(exists("polaris.adj"), values(polaris.adj)*10, NA),
                    ifelse(exists("landgis.adj"), values(landgis.adj)*10, NA),
                    na.rm=TRUE)),
          ceiling(max(values(sg.adj)*10,
                      values(gsm.crop)*10, 
                      ifelse(exists("issr8.adj"), values(issr8.adj)*10,  NA),
                      ifelse(exists("psu.adj"), values(psu.adj)*10, NA),
                      ifelse(exists("polaris.adj"), values(polaris.adj)*10, NA),
                      ifelse(exists("landgis.adj"), values(landgis.adj)*10, NA),
                      na.rm=TRUE)))/10
print(zlim.adj)
```

These are now similar in their ranges, but not in their patterns.

Removing bias changes the spatial statistics only slightly, because the cut points in classification are the same so some pixels change classes.

So for now, _do not adjust_: here we re-set the "adjusted" to the original:

```{r reset.adj}
# gsm was the basis
sg.adj <- sg.crop
if (exists("psu.crop")) psu.adj <- psu.crop
if (exists("polaris.crop")) polaris.adj <- polaris.crop
if (exists("landgis.crop")) landgis.adj <- landgis.crop
if (exists("issr8.crop")) issr8.adj <- issr8.crop
zlim.adj <- zlim
```


# Classify

The metrics used require classified maps, so we must classify into ranges. These can be of several types:

1. fixed, set by analyst. E.g., pH in 0.5 increments. These classes should have some application significance, e.g., limits in Soil Taxonomy or land capability systems.

2. "natural" classes from histograms or k-means,

In both cases using sharp class boundaries can lead to artefacts caused by the PSM method.

## Histogram equalization   
A better method is histogram equalization, with a user-defined number of classes. This avoids subjectivity and will work on any property.


```{r hist.equal.cuts, fig.width=8, fig.height=4}
n.class <- 8
#
values.all <- c(values(gsm.crop),
                values(sg.adj), 
                ifelse(exists("issr8.adj"), values(issr8.adj), NA),
                ifelse(exists("psu.adj"), values(psu.adj), NA),
                ifelse(exists("landgis.adj"), values(landgis.adj), NA),
                ifelse(exists("polaris.adj"), values(polaris.adj), NA))
length(values.all)
summary(values.all)
values.all.sort <- sort(values.all)
#
n <- length(values.all)
(cut.positions <- round(n/n.class))
(cuts <- values.all.sort[cut.positions * 1:(n.class-1)])
hist(values.all, breaks=36, main="Histogram equalization")
abline(v=cuts, col="blue", lwd=2)
```


We set up a colour ramp that covers the entire range, and then select the colours out of it that match the actual value range.


```{r classify.raster}
(cut.names <- cut(zlim.adj, breaks=c(zlim.adj[1], cuts, zlim.adj[2]), ordered_result=TRUE))
# common colour ramp
color.ramp <- bpy.colors(n.class)
#
(class.limits <- c(zlim.adj[1], cuts, zlim.adj[2]))
gsm.class <- classify(gsm.crop, rcl=class.limits)
# gsm.class <- as.factor(gsm.class)
table(values(gsm.class))
# .l <- range(values(gsm.class), na.rm=TRUE)
# terra::plot(gsm.class,
#             col=color.ramp[.l[1]:.l[2]], type="classes",
#             main="SoilGrids250")
#
sg.class <- classify(sg.adj, rcl=class.limits)
# sg.class <- as.factor(sg.class)
table(values(sg.class))
# .l <- range(values(sg.class), na.rm=TRUE)
# terra::plot(sg.class,
#             col=color.ramp[.l[1]:.l[2]], type="classes",
#             main="SoilGrids250")
#
if (exists("issr8.adj")) {
  issr8.class <- classify(issr8.adj, rcl=class.limits)
  table(values(issr8.class))
  # issr8.class <- as.factor(issr8.class)
  # .l <- range(values(issr8.class), na.rm=TRUE)
  # terra::plot(issr8.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="ISSR-800")
  #
}
if (exists("psu.adj")) {
  psu.class <- classify(psu.adj, rcl=class.limits)
  # psu.class <- as.factor(psu.class)
  table(values(psu.class))
  # .l <- range(values(psu.class), na.rm=TRUE)
  # terra::plot(psu.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="SPCG100USA")
  #
}
if (exists("polaris.adj")) {
  polaris.class <- classify(polaris.adj, rcl=class.limits)
  # psu.class <- as.factor(psu.class)
  table(values(polaris.class))
  # .l <- range(values(polaris.class), na.rm=TRUE)
  # terra::plot(polaris.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="POLARIS")
  #
}
if (exists("landgis.adj")) {
  landgis.class <- classify(landgis.adj, rcl=class.limits)
  # psu.class <- as.factor(psu.class)
  table(values(landgis.class))
  # .l <- range(values(landgis.class), na.rm=TRUE)
  # terra::plot(landgis.class,
  #             col=color.ramp[.l[1]:.l[2]], type="classes",
  #             main="LandGIS")
  #
}
```

```{r show.classified, fig.width=12, fig.height=18}
par(mfrow=c(3,2))
.l <- range(values(gsm.class), na.rm=TRUE)
terra::plot(gsm.class,
            col=color.ramp[.l[1]:.l[2]], type="classes",
            main="GSM v0.5")
.l <- range(values(sg.class), na.rm=TRUE)
terra::plot(sg.class,
            col=color.ramp[.l[1]:.l[2]], type="classes",
            main="SoilGrids250")
if (exists("psu.class")) {
  .l <- range(values(psu.class), na.rm=TRUE)
  terra::plot(psu.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="SPCG100USA")
}
if (exists("polaris.class")) {
  .l <- range(values(polaris.class), na.rm=TRUE)
  terra::plot(polaris.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="POLARIS")
}
if (exists("landgis.class")) {
  .l <- range(values(issr8.class), na.rm=TRUE)
  terra::plot(landgis.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="LandGIS")
}
if (exists("issr8.class")) {
  .l <- range(values(issr8.class), na.rm=TRUE)
  terra::plot(issr8.class,
              col=color.ramp[.l[1]:.l[2]], type="classes",
              main="ISSR-800")
}
par(mfrow=c(1,1))
```

## Cross-classification

Cross-classification GSM (rows) vs. SoilGrids250 (columns):

```{r xclass.1}
table(as.vector(gsm.class), as.vector(sg.class))
```

Cross-classification GSM (rows) vs. SPCG100USA (columns):

```{r xclass.2}
if (exists("psu.class")) { 
  table(as.vector(gsm.class), as.vector(psu.class))
}
```

Cross-classification GSM (rows) vs. POLARIS (columns):

```{r xclass.2a}
if (exists("polaris.class")) {
  table(as.vector(gsm.class), as.vector(polaris.class))
}
```

```{r xclass.2b}
if (exists("landgis.class")) { 
  table(as.vector(gsm.class), as.vector(landgis.class))
}
```

Cross-classification SoilGrids250 (rows) vs. SPCG100USA (columns):

```{r xclass.3}
if (exists("psu.class")) { 
  table(as.vector(sg.class), as.vector(psu.class))
}
```



Much closer agreement between the two products using PSM, also closer agreement between the two products derived from SSURGO.

## Polygonize

The V-metrics require polygon maps, not gridded maps of classes.

Polygonize them:

```{r polygonize}
gsm.poly <- terra::as.polygons(gsm.class, dissolve=TRUE, trunc=FALSE)
sg.poly <- terra::as.polygons(sg.class, dissolve=TRUE, trunc=FALSE)
if (exists("issr8.class")) issr8.poly <- terra::as.polygons(issr8.class, dissolve=TRUE, trunc=FALSE)
if (exists("psu.class")) psu.poly <- terra::as.polygons(psu.class, dissolve=TRUE, trunc=FALSE)
if (exists("polaris.class")) polaris.poly <- terra::as.polygons(polaris.class, dissolve=TRUE, trunc=FALSE)
if (exists("landgis.class")) landgis.poly <- terra::as.polygons(landgis.class, dissolve=TRUE, trunc=FALSE)
```

## Simple Features

Some of the methods require Simple Features representation of spatial objects.

Convert the `terra::SpatVector` objects to Simple Features. As of now (2020-08-29) there seems to be no direct way, so save as a vector file and read into `sf`:

```{r convert.polygons.sf}
#
tmpf1 <- tempfile()
terra::writeVector(gsm.poly, tmpf1, overwrite=TRUE)
gsm.sf <- st_read(tmpf1); unlink(tmpf1)
names(gsm.sf)[1] <- "class"
#
tmpf2 <- tempfile()
terra::writeVector(sg.poly, tmpf2, overwrite=TRUE)
sg.sf <- st_read(tmpf2); unlink(tmpf2)
names(sg.sf)[1] <- "class"
#
if (exists("psu.class")) {
  tmpf3 <- tempfile()
  terra::writeVector(psu.poly, tmpf3, overwrite=TRUE)
  psu.sf <- st_read(tmpf3); unlink(tmpf3)
  names(psu.sf)[1] <- "class"
}
#
if (exists("polaris.class")) {
  tmpf4 <- tempfile()
  terra::writeVector(polaris.poly, tmpf4, overwrite=TRUE)
  polaris.sf <- st_read(tmpf4); unlink(tmpf4)
  names(polaris.sf)[1] <- "class"
}
#
if (exists("issr8.class")) { 
  tmpf5 <- tempfile()
  terra::writeVector(issr8.poly, tmpf5, overwrite=TRUE)
  issr8.sf <- st_read(tmpf5); unlink(tmpf5)
  colnames(issr8.sf)[1] <- "class"
}
if (exists("landgis.class")) {
  tmpf6 <- tempfile()
  terra::writeVector(landgis.poly, tmpf6, overwrite=TRUE)
  landgis.sf <- st_read(tmpf6); unlink(tmpf6)
  colnames(landgis.sf)[1] <- "class"
}
#
```

This is a Simple feature collection with 4 features and 1 field (and the geometry).

## Topology

The topology is not correct, so `vmeasure_calc` throws an error. Clean up the topology with `sf::st_make_valid`.

See https://www.r-spatial.org/r/2017/03/19/invalid.html. 

```{r}
st_is_valid(gsm.sf, reason=TRUE)
gsm.sf.v <- sf::st_make_valid(gsm.sf)
# st_is_valid(gsm.sf.v, reason=TRUE)
#
st_is_valid(sg.sf, reason=TRUE)
sg.sf.v <- sf::st_make_valid(sg.sf)
# st_is_valid(sg.sf.v, reason=TRUE)
if (exists("issr8.sf")) {
  st_is_valid(issr8.sf, reason=TRUE)
  issr8.sf.v <- sf::st_make_valid(issr8.sf)
  # st_is_valid(issr8.sf.v, reason=TRUE)
}
if (exists("psu.sf")) {
  st_is_valid(psu.sf, reason=TRUE)
  psu.sf.v <- sf::st_make_valid(psu.sf)
  # st_is_valid(psu.sf.v, reason=TRUE)
}
if (exists("polaris.sf")) {
  st_is_valid(polaris.sf, reason=TRUE)
  polaris.sf.v <- sf::st_make_valid(polaris.sf)
  # st_is_valid(polaris.sf.v, reason=TRUE)
}
if (exists("landgis.sf")) {
  st_is_valid(landgis.sf, reason=TRUE)
  landgis.sf.v <- sf::st_make_valid(landgis.sf)
  # st_is_valid(landgis.sf.v, reason=TRUE)
}
```


Now the topology is correct.

## Plot the polygonized class maps

Display the maps. Compute each legend from the classes present in that map.

```{r class_maps, fig.width=7, fig.height=5}
my.pal <- brewer.pal(n.class, "RdYlGn")
l.gsm <- range(gsm.sf.v$class, na.rm = TRUE)
l.sg <- range(sg.sf.v$class, na.rm = TRUE)
if (exists("issr8.sf")) { l.issr8 <- range(issr8.sf.v$class, na.rm = TRUE) }
if (exists("psu.sf")) { l.psu <- range(psu.sf.v$class, na.rm = TRUE) }
if (exists("polaris.sf")) { l.polaris <- range(polaris.sf.v$class, na.rm = TRUE) }
if (exists("landgis.sf")) { l.landgis <- range(landgis.sf.v$class, na.rm = TRUE) }
g0 <- ggplot(data=gsm.sf.v) +
  geom_sf(aes(fill = class)) +
  coord_sf(crs = st_crs(gsm.sf)) +
#  guides(fill=FALSE) +   # no legend on the two leftmost
# no, that distorts the size compared to the one with legend
   labs(title = "GSV v0.5")  +
  scale_fill_continuous(low=my.pal[l.gsm[1]], high=my.pal[l.gsm[2]]) +
  theme(legend.position = "bottom", legend.direction = "horizontal")
g1 <- ggplot(data=sg.sf.v) +
  geom_sf(aes(fill = class)) +
  coord_sf(crs = st_crs(sg.sf)) +
  labs(title = "SoilGrids250")  +
  scale_fill_continuous(low=my.pal[l.sg[1]], high=my.pal[l.sg[2]]) +
  theme(legend.position = "bottom", legend.direction = "horizontal")
if (exists("issr8.sf")) { 
  g2 <- ggplot(data=issr8.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "ISSR-800")  +
    scale_fill_continuous(low=my.pal[l.issr8[1]], high=my.pal[l.issr8[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
if (exists("psu.sf")) { 
  g3 <- ggplot(data=psu.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "SPCG100USA") +
    scale_fill_continuous(low=my.pal[l.psu[1]], high=my.pal[l.psu[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
if (exists("polaris.sf")) { 
  g4 <- ggplot(data=polaris.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "POLARIS") +
    scale_fill_continuous(low=my.pal[l.polaris[1]], high=my.pal[l.polaris[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
if (exists("landgis.sf")) { 
  g5 <- ggplot(data=landgis.sf.v) +
    geom_sf(aes(fill = class)) +
    coord_sf(crs = st_crs(sg.sf)) +
    labs(title = "LandGIS") +
    scale_fill_continuous(low=my.pal[l.landgis[1]], high=my.pal[l.landgis[2]]) +
    theme(legend.position = "bottom", legend.direction = "horizontal")
}
# show them separately, because we don't which ones are defined
# then arrange manually in the paper
print(g0)
print(g1)
print(g2)
print(g3)
print(g4)
print(g5)
```



# Metrics from the `sabre` package

These metrics are explained in:

Nowosad, J., & Stepinski, T. F. (2018). Spatial association between regionalizations using the information-theoretical V-measure. International Journal of Geographical Information Science, 32(12), 2386–2401. https://doi.org/10.1080/13658816.2018.1511794

and implemented in the `sabre` package:

## V metrics {#vmetrics}

The _V-measure_ originated in the field of computer science as a measure for comparison of different clusterings of the same domain.  It is a measure of an overall spatial correspondence between classified maps -- these are analogous to clusterings. So continuous maps (as in this study) must be classified into the same classes, and the two classified maps then compared.

"The V-measure method has several advantages over the widely used Mapcurves method, it has clear interpretations in terms of mutual information as well as in terms of analysis of variance, 

_Homogeneity_ shows an average homogeneity of the regions in the 2nd map with respect to the regions in the 1st, i.e., how close the 2nd map comes to reproducing the 1st

_Completeness_ is a function of homogeneity of the regions in the 1st map with respect to the regions in the 2nd, i.e., how much the regions in the 1st map reproduce those of the 2nd 
These do not depend on the class labels, only on the number/quantity of regions (classes) in the source map compared to given region of the target map. 

This function uses the `sf::st_intersection()`,m which depends on the coordinates values precision.
(For example, precision = 1000 rounds values to the third decimal places and precision = 0.001
uses values rounded to the nearest 1000, see `sf::st_as_binary`).



The `vmeasure_calc()` function calculates intersections of the input geometries.
For this function we must specify the names of the columns with the region names; both x and y must contain `POLYGON`s or `MULTIPOLYGON`s and have the same CRS. 



## Compute metrics

Compute the metrics with the `sabre` package.

### GSM vs. SoilGrids

```{r gsm8.sg}
regions.gsm.sg <- vmeasure_calc(x = gsm.sf.v, 
                                 y = sg.sf.v, 
                                 x_name = class, y_name = class)
class(regions.gsm.sg) 
print(regions.gsm.sg)
names(regions.gsm.sg)
names(regions.gsm.sg$map1)
```

`rih` is the intersection map. Show these:

Geometric precision is set by `st_as_binary`, default is `attr(x, "precision")`. Here we didn't change it and the intersection looks good.

```{r}
attr(regions.gsm.sg, "precision")  # NULL, means a system default
```

Here we leave it as the default `NULL`.

```{r vmaps.gsm.sg}
  ## produced maps -- the homogeneity of the regions.gsm.sg
terra::plot(regions.gsm.sg$map1["rih"], main = "Homogeneity -- SG250 vs. GSM")
terra::plot(regions.gsm.sg$map2["rih"], main = "Completeness -- SG250 vs. GSM")
```

### GSM vs. SPCG100USA

```{r gsm.psu}
regions.gsm.psu <- vmeasure_calc(x = gsm.sf.v, 
                                  y = psu.sf.v, 
                                  x_name = class, y_name = class)
class(regions.gsm.psu) 
print(regions.gsm.psu)
names(regions.gsm.psu)
names(regions.gsm.psu$map1)
```


```{r vmaps.gsm.psu}
## produced maps -- the homogeneity of the regions.gsm.psu
terra::plot(regions.gsm.psu$map1["rih"], main = "Homogeneity -- SPCG100USA vs. GSM")
terra::plot(regions.gsm.psu$map2["rih"], main = "Completeness -- SPCG100USA vs. GSM")
```

### GSM vs. POLARIS

```{r gsm.polaris}
regions.gsm.polaris <- vmeasure_calc(x = gsm.sf.v, 
                                      y = polaris.sf.v, 
                                      x_name = class, y_name = class)
class(regions.gsm.polaris) 
print(regions.gsm.polaris)
names(regions.gsm.polaris)
names(regions.gsm.polaris$map1)
```


```{r vmaps.gsm.polaris}
## produced maps -- the homogeneity of the regions.gsm.polaris
terra::plot(regions.gsm.psu$map1["rih"], main = "Homogeneity -- POLARIS vs. GSM")
terra::plot(regions.gsm.psu$map2["rih"], main = "Completeness -- POLARIS vs. GSM")
```

### SoilGrids250 vs. SPCG100USA

```{r sg.psu}
regions.sg.psu <- vmeasure_calc(x = sg.sf.v, 
                                y = psu.sf.v, 
                                x_name = class, y_name = class)
class(regions.sg.psu) 
print(regions.sg.psu)
names(regions.sg.psu)
names(regions.sg.psu$map1)
```


```{r vmaps.sg.psu}
## produced maps -- the homogeneity of the regions
terra::plot(regions.sg.psu$map1["rih"], main = "Homogeneity -- SPCG100USA -- SoilGrids250")
terra::plot(regions.sg.psu$map2["rih"], main = "Completeness -- SPCG100USA -- SoilGrids250")
```

## Table with `vmeasure` statistics

```{r}
str(regions.gsm.sg, max.level = 1)
vmeasure.compare <- data.frame(PSM_products = "", V_measure = 0, Homogeneity = 0, Completeness = 0)
vmeasure.compare[1,] <- c("GSM v0.5 vs. SG2", 
                       round(regions.gsm.sg$v_measure, 4),
                       round(regions.gsm.sg$homogeneity, 4),
                       round(regions.gsm.sg$completeness, 4)
                       )
i <- 1
if (exists("regions.gsm.psu")) {
  vmeasure.compare[i <- i+1,] <- c("GSM v0.5 vs. SPCG100USA", 
                            round(regions.gsm.psu$v_measure, 4),
                            round(regions.gsm.psu$homogeneity, 4),
                            round(regions.gsm.psu$completeness, 4)
  )
}
if (exists("regions.gsm.polaris")) {
  vmeasure.compare[i <- i+1,] <- c("GSM v0.5 vs. POLARIS", 
                            round(regions.gsm.polaris$v_measure, 4),
                            round(regions.gsm.polaris$homogeneity, 4),
                            round(regions.gsm.polaris$completeness, 4)
  )
}
if (exists("regions.gsm.psu")) {
  vmeasure.compare[i <- i+1,] <- c("SG2 va. SPCG100USA", 
                       round(regions.sg.psu$v_measure, 4),
                       round(regions.sg.psu$homogeneity, 4),
                       round(regions.sg.psu$completeness, 4)
                       )
  
}
print(vmeasure.compare)
```

Save for paper:


```{r}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(vmeasure.compare, row.names=FALSE, digits=3)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), file=
                 paste0("../LaTeX_tables/compare_vmeasure_",
                           aoi, "_", voi.depth, ".tex"))
```


# Landscape metrics (`landscapemetrics` package) {#landscapemetrics}

This package implements a set of metrics as used in ecology and derived from the FRAGSTATS computer program.

Package: https://r-spatialecology.github.io/landscapemetrics/index.html

Reference: Hesselbarth, M. H. K., Sciaini, M., With, K. A., Wiegand, K., & Nowosad, J. (2019). landscapemetrics: An open-source R tool to calculate landscape metrics. Ecography, 42, 1648–1657. https://doi.org/10.1111/ecog.04617

## Convert to `raster`

These packages work with `raster` objects, so convert from `terra` structures.

```{r}
r.gsm <- raster(gsm.class)
r.sg <- raster(sg.class)
if (exists("issr8.class")) r.issr8 <- raster(issr8.class)
if (exists("psu.class"))r.psu <- raster(psu.class)
if (exists("polaris.class"))r.polaris <- raster(polaris.class)
if (exists("landgis.class"))r.landgis <- raster(landgis.class)
```

A function to display the landscape with a consistent colour ramp:

```{r show.landscape.function}
(my.pal <- c(brewer.pal(n.class, "RdYlGn"), "#FFFFFF"))
show.landscape <- function(r.map, r.title) {
  check_landscape(r.map)
  l <- range(values(r.map), na.rm = TRUE)
  g <- show_landscape(r.map, discrete = TRUE) +
    # use the positions in the palette corresponding to the class numbers
    # force the NA to the last entry in the palette
    scale_fill_manual(values=c(my.pal[l[1]:l[2]], my.pal[n.class+1])) +
    theme(legend.position = "bottom",
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          legend.title = element_blank()) +
    labs(title = r.title)
  return(g)
}
```

Show the landscapes of each product:

```{r show.landscape, fig.width=7, fig.height=5}
(g1 <- show.landscape(r.gsm, "GSM v0.5"))
(g2 <- show.landscape(r.sg, "SoilGrids250"))
if (exists("r.psu")) (g3 <- show.landscape(r.psu, "SPCG100USA"))
if (exists("r.polaris")) (g4 <- show.landscape(r.polaris, "POLARIS"))
if (exists("r.landgis")) (g4 <- show.landscape(r.landgis, "LandGIS"))
if (exists("r.issr8")) (g4 <- show.landscape(r.issr8, "ISSR-800"))
```


## Metrics list

"All functions in `landscapemetrics` start with `lsm_`. The second part of the name specifies the level (patch - `p`, class - `c` or landscape - `l`). The last part of the function name is the abbreviation of the corresponding metric (e.g. `enn` for the euclidean nearest-neighbor distance)."

Here are all the landscape-level metrics:

```{r}
list_lsm(level="landscape") %>% print(n=Inf)
ls.metrics <- calculate_lsm(r.sg, level = "landscape")
(ls.metrics) %>% print(n=16)
data.frame(ls.metrics)
```

All the class-level metrics:

```{r}
list_lsm(level="class")  %>% print(n=Inf)
class.metrics <- calculate_lsm(r.sg, level = "class")
(class.metrics)
```

All the patch-level metrics:

```{r}
list_lsm(level="patch")  %>% print(n=Inf)
patch.metrics <- calculate_lsm(r.sg, level = "patch")
(patch.metrics)
```



## Visualize class and patch metrics

Core areas for each _class_. These are the "typical" areas, used mainly for habitats. Here they show where the class is concentrated.

```{r show.core.areas, fig.width=12, fig.height=12}
show_cores(r.gsm)
show_cores(r.sg)
if (exists("r.issr8")) show_cores(r.issr8)
if (exists("r.psu")) show_cores(r.psu)
if (exists("r.polaris")) show_cores(r.polaris)
if (exists("r.landgis")) show_cores(r.landgis)
```

Show the landscape with a patch-level metric in each _patch_. For example, the contiguity of each patch:

```{r show.patch.level.metrics, fig.width=6, fig.height=6}
show_lsm(r.gsm, what="lsm_p_contig")
show_lsm(r.sg, what="lsm_p_contig")
if (exists("r.issr8")) show_lsm(r.issr8, what="lsm_p_contig")
if (exists("r.psu")) show_lsm(r.psu, what="lsm_p_contig")
if (exists("r.polaris")) show_lsm(r.polaris, what="lsm_p_contig")
if (exists("r.landgis")) show_lsm(r.landgis, what="lsm_p_contig")
```

But we want landscape-level metrics, we are not interested in individual patches.

Here are the landscape-level metrics we will report:

```{r}
lst <- paste0("lsm_l_", c("shdi", "shei", "lsi", "frac_mn"))
ls.metrics.gsm <- calculate_lsm(r.gsm, what=lst)
ls.metrics.sg <- calculate_lsm(r.sg, what=lst)
ls.metrics.issr8 <- ifelse(exists("r.issr8"), calculate_lsm(r.issr8, what=lst),
                           rep(NA, 4))
ls.metrics.psu <- ifelse(exists("r.psu"), calculate_lsm(r.psu, what=lst),
                         rep(NA,4))
ls.metrics.polaris <- ifelse(exists("r.polaris"), calculate_lsm(r.polaris, what=lst),
                             rep(NA, 4))
ls.metrics.landgis <- ifelse(exists("r.landgis"), calculate_lsm(r.landgis, what=lst),
                             rep(NA,4))  
```

Make a table with the metrics for the several products.

```{r}
metrics.table <- data.frame(product=c("GSM", "SoilGrids", "SPCG100USA", "POLARIS", "ISSR8", "LandGIS"),
                            rbind(ls.metrics.gsm$value,
                                  ls.metrics.sg$value,
                                  ls.metrics.psu$value,
                                  ls.metrics.polaris$value,
                                  ls.metrics.issr8$value,
                                  ls.metrics.landgis$value))
names(metrics.table)[2:5] <- ls.metrics.gsm$metric
```


```{r metrics.table}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(metrics.table, row.names=FALSE, digits=3)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), file=
                 paste0("../LaTeX_tables/landscape_metrics_",
                           aoi, "_", voi.depth, ".tex"))
```

# Local spatial structure

The variogram (equivalent to correlogram) can be used to characterize the degree of spatial continuity and the "roughness" of a continuous property map. This must be applied to an object of class `sp`.

Distances computed by `gstat` for objects with geographic coordinates ar in great-circle km.
So, the initial range estimate is in km. The initial partial sill is the maximum semivariance of the empirical variogram.

```{r}
range.init <- 2
cutoff.init <- range.init*2.5
```

Compute the short-range variogram, this reveals the local structure. In these maps the variogram is typically unbounded, but we don't care about the long-range structure.

Model the variograms with the Spherical model, appropriate to patchiness typical of soil properties.

<!-- Compute the variograms at the exact distance of the grid, up to 4 grid cell separation. -->

Use a metric version of the map for variogram analysis. To do this, we need a CRS, and we use the appropriate UTM zone:

```{r find.utm.crs}
long2UTM <- function(long) {
    (floor((long + 180)/6) %% 60) + 1
}
utm.zone <- long2UTM(tile.lrc[1])
# EPSG code for WGS84 UTM zones N are 326xx, where xx=UTM zone number
# from epsg.org
(utm.epsg <- 32600 + utm.zone)
crs.utm <- CRS(paste0("+init=epsg:", utm.epsg))
```

Initial parameters for empirical variograms and models:

```{r}
range.init <- 2000
cutoff.init <- range.init*2.5
```

Compute and model variograms. Note the estimated sill is the maximum $\gamma$ in the empirical variogram.

```{r compute.variogram, fig.height=6, fig.width=8}
gsm.sp <- as(raster(gsm.crop), "SpatialPointsDataFrame")
gsm.sp <- spTransform(gsm.sp, crs.utm)
v.gsm <- gstat::variogram(voi ~ 1, loc = gsm.sp, cutoff=cutoff.init, width=500)
vm.gsm <- vgm(max(v.gsm$gamma), "Exp", range.init, 0)
(vmf.gsm <- fit.variogram(v.gsm, model=vm.gsm))
# plot(v.gsm, pl=T, model=vmf.gsm)
#
sg.sp <- as(raster(sg.adj), "SpatialPointsDataFrame")
sg.sp <- spTransform(sg.sp, crs.utm)
v.sg <- variogram(voi ~ 1, loc = sg.sp, cutoff=cutoff.init, width=500)
vm.sg <- vgm(max(v.sg$gamma), "Exp", range.init, 0)
(vmf.sg <- fit.variogram(v.sg, model=vm.sg))
# plot(v.sg, pl=T, model=vmf.sg)
#
if (exists("r.issr8")) {
  issr8.sp <- as(raster(issr8.adj), "SpatialPointsDataFrame")
  issr8.sp <- spTransform(issr8.sp, crs.utm)
  v.issr8 <- variogram(voi ~ 1, loc = issr8.sp, cutoff=cutoff.init, width=500)
  vm.issr8 <- vgm(max(v.issr8$gamma), "Exp", range.init, 0)
  vmf.issr8 <- fit.variogram(v.issr8, model=vm.issr8)
#  plot(v.issr8, pl=T, model=vmf.issr8)
}
if (exists("r.psu")) {
  psu.sp <- as(raster(psu.adj), "SpatialPointsDataFrame")
  psu.sp <- spTransform(psu.sp, crs.utm)
  v.psu <- variogram(voi ~ 1, loc = psu.sp, cutoff=cutoff.init, width=500)
  vm.psu <- vgm(max(v.psu$gamma), "Exp", range.init, 0)
  vmf.psu <- fit.variogram(v.psu, model=vm.psu)
#  plot(v.psu, pl=T, model=vmf.psu)
}
if (exists("r.polaris")) {
  polaris.sp <- as(raster(polaris.adj), "SpatialPointsDataFrame")
  polaris.sp <- spTransform(polaris.sp, crs.utm)
  v.polaris <- variogram(voi ~ 1, loc = polaris.sp, cutoff=cutoff.init, width=500)
  vm.polaris <- vgm(max(v.polaris$gamma), "Exp", range.init, 0)
  vmf.polaris <- fit.variogram(v.polaris, model=vm.polaris)
#  plot(v.polaris, pl=T, model=vmf.polaris)
}
if (exists("r.landgis")) {
  landgis.sp <- as(raster(landgis.adj), "SpatialPointsDataFrame")
  landgis.sp <- spTransform( landgis.sp, crs.utm)
  v.landgis <- variogram(voi ~ 1, loc = landgis.sp, cutoff=cutoff.init, width=500)
  vm.landgis <- vgm(max(v.landgis$gamma), "Exp", range.init, 0)
  vmf.landgis <- fit.variogram(v.landgis, model=vm.landgis)
#  plot(v.landgis, pl=T, model=vmf.landgis)
}
```


Make a table of the variogram parameters:

```{r table.compare.variograms}
vmeasure.compare <- data.frame(PSM_products = "", Range = 0, StructSill = 0, PropNugget = 0)
vmeasure.compare[1,] <- c("GSM v0.5", 
                       round(vmf.gsm[2,"range"], 0),
                       round(vmf.gsm[2,"psill"], 2),
                       round(vmf.gsm[1,"psill"]/sum(vmf.issr8[,"psill"]), 2)
                       )
vmeasure.compare[2,] <- c("SG2", 
                       round(vmf.sg[2,"range"], 0),
                       round(vmf.sg[2,"psill"], 2),
                       round(vmf.sg[1,"psill"]/sum(vmf.sg[,"psill"]), 2)
                       )
i <- 2
if(exists("vmf.psu")) {
  vmeasure.compare[(i <- i+1), ] <-  c("SPCG100USA", 
                       round(vmf.psu[2,"range"], 0),
                       round(vmf.psu[2,"psill"], 2),
                       round(vmf.psu[1,"psill"]/sum(vmf.psu[,"psill"]), 2))
}
if(exists("vmf.polaris")) {
  vmeasure.compare[(i <- i+1), ] <-  c("POLARIS", 
                       round(vmf.polaris[2,"range"], 0),
                       round(vmf.polaris[2,"psill"], 2),
                       round(vmf.polaris[1,"psill"]/sum(vmf.polaris[,"psill"]), 2))
}
if(exists("vmf.issr8")) {
  vmeasure.compare[(i <- i+1), ] <- c("ISSR-800", 
                       round(vmf.issr8[2,"range"], 0),
                       round(vmf.issr8[2,"psill"], 2),
                       round(vmf.issr8[1,"psill"]/sum(vmf.issr8[,"psill"]), 2))
}
if(exists("vmf.landgis")) {
  vmeasure.compare[(i <- i+1), ] <-  c("landgis", 
                       round(vmf.landgis[2,"range"], 0),
                       round(vmf.landgis[2,"psill"], 2),
                       round(vmf.landgis[1,"psill"]/sum(vmf.landgis[,"psill"]), 2))
}
# multiply all range parameters by 3 to get effective range
vmeasure.compare[, 2:4] <- apply(vmeasure.compare[, 2:4],  2, as.numeric)
vmeasure.compare[, "Range"] <- vmeasure.compare[, "Range"]*3
print(vmeasure.compare)
```


```{r write.table.compare.variograms}
options(xtable.floating = FALSE)
options(xtable.timestamp = "")
x <- xtable(vmeasure.compare, row.names=FALSE, digits=3)
autoformat(x)
capture.output(print(x, include.rownames=FALSE), file=
                 paste0("../LaTeX_tables/compare_variograms_",
                           aoi, "_", voi.depth, ".tex"))
```


Plot the variograms with the fitted models:

```{r plot.vgms, fig.width=12, fig.height=8}
ylims <- c(0, max(v.issr8$gamma, v.sg$gamma,  
                  v.psu$gamma, v.polaris$gamma,
                  v.issr8$gamma, v.landgis$gamma)*1.1)
p1 <- plot(v.gsm, ylim=ylims, model=vmf.gsm, main="GSM v0.5", xlab="separation (m)", pch=20)
p2 <- plot(v.sg, ylim=ylims, model=vmf.sg, main="SoilGrids250", xlab="separation (m)", pch=20)
if(exists("vmf.psu")) {
  p3 <- plot(v.psu, ylim=ylims, model=vmf.psu, main="SPCG100USA", xlab="separation (m)", pch=20)
} else p3 <- NULL
if(exists("vmf.polaris")) {
  p4 <- plot(v.polaris, ylim=ylims, model=vmf.polaris, main="POLARIS", xlab="separation (m)", pch=20)
} else p4 <- NULL
if(exists("vmf.issr8")) {
  p5 <- plot(v.issr8, ylim=ylims, model=vmf.issr8, main="ISSR-800", xlab="separation (m)", pch=20)
} else p5 <- NULL
if(exists("vmf.landgis")) {
  p6 <- plot(v.landgis, ylim=ylims, model=vmf.landgis, main="LandGIS", xlab="separation (m)", pch=20)
} else p6 <- NULL
print(p1, split=c(1,1,3,2), more=T)
print(p4, split=c(1,2,3,2), more=T)
print(p2, split=c(2,1,3,2), more=T)
print(p5, split=c(2,2,3,2), more=T)
print(p6, split=c(3,1,3,2), more=T)
print(p3, split=c(3,2,3,2), more=F)
```

