---
title: "gNATSGO -- Import via WCS for PSM comparisons"
author:
  - "D G Rossiter"
  - "d.g.rossiter@cornell.edu"
date: "`r format(Sys.Date(), '%d-%B-%Y')`"
params:
   lrc_long: -76
   lrc_lat: 42 
   size: 1
   quantile.n: NA
   voi.n: 4
   depth.n: 4
output:
  html_document:
    fig_align: center
    fig_height: 6
    fig_width: 6
    fig_caption: false
    number_section: yes
    theme: spacelab
    df_print: paged
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      purl=FALSE, 
                      fig.align = 'center')
knitr::opts_chunk$set(cache.extra = R.version.string, comment="")
```

# Introduction

[gNATSGO](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/geo/?cid=nrcseprd1464625) "is a USDA-NRCS Soil & Plant Science Division (SPSD) composite database that provides complete coverage of the best available soils information for all areas of the United States and Island Territories. It was created by combining data from the Soil Survey Geographic Database (SSURGO), State Soil Geographic Database (STATSGO2), and Raster Soil Survey Databases (RSS) offsite link image into a single seamless ESRI file geodatabase."

It is thus the most authoritative digital product, representing many decades of field work and subsequent compilation.

A description (more or less) is [here](https://nrcs.app.box.com/v/soils/file/744008197230). Unfortunately the instructions are for an ArcInfo toolkit "gSSURGO tools", and it applies to the State-wide products, not the CONUS product.

Web Coverage Service (WCS) access is now provided by NRCS; we use that in this script.

This script creates a tile for a property and depth slice, over a Area of Interest delimited by geographic coordinates, that can then be compared with other PSM products. 

To use this script:

Steps 1--4 refer to the YAML headers, or external calls with `knitr::render`.

1. Ajust the [directory structure](#dirs) to your system

2. [Select a property](#prop) and [select a depth slice](#depth), using the YAML header or by knitting with parameters.

3. [Select an Area of Interest](#aoi), using the YAML header or by knitting with parameters.

4. Either compile to HTML or PDF ("knit"), or "Run All" within R Markdown.

5. The processed tile will be in the directory structure, in a [subdirectory named for the AOI](#save).

# Packages and Drivers

```{r pack}
library(sf)
library(sp)
library(rgdal)
library(aqp)
library(soilDB)
library(tidyverse)
# library(terra) 
library(raster) 
library(rasterVis)
``` 


# Directories {#dirs}

One directory is used for the large original files (all-CONUS grid and all-map unit database), and another for the extracted tiles. Set these to areas on your own system.

```{r}
base.dir.gnatsgo <- "/Users/rossiter/ds/gNATSGO"
base.dir.gnatsgo.import <- "/Volumes/Pythagoras/ds/gNATSGO"
```

# WCS Access



# Attribute database

 
CRS is a CONUS Albers Equal Area.



# Parameters

Parameters for this run:

```{r}
print(paste("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat, "; size:", params$size))
print(paste("voi.n:", params$voi.n, "; depth.n:", params$depth.n))
```

## Property of interest {#prop}

The following properties can be compared to SoilGrids250 and other PSM products.

Note the ``_r` in the name, this means "representative value".


```{r voi.list}
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.list.gnatsgo <- c("claytotal_r", "silttotal_r", "sandtotal_r",
                  "ph1to1h2o_r", "ecec_r", "soc_r", 
                  "dbthirdbar_lt2mm_r", "gravel_r")
```

*Select a property* by its position in the list, and make a full name from it:

```{r voi}
(voi.name <- voi.list.gnatsgo[params$voi.n])
```


## Depth of interest {#depth}

```{r depth.list}
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.list.gnatsgo <- c("05", "515", "1530", "3060", "60100", "100200")
```

*Select a depth slice* by its position in the list, based on the YAML or run-time parameter, and make a full name from the property of interest and the selected depth slice:

```{r depth}
depth.gnatsgo <- depth.list.gnatsgo[params$depth.n]
(voi.depth.name <- paste0(voi.name, "_", depth.gnatsgo))  # , "cm"
```


## Area of Interest (AOI) {#aoi}

Specify the lower-right corner from the YAML or rendering parameters:

```{r lrc}
tile.lrc <- c(params$lrc_long, params$lrc_lat) # lower-right corner
```

Compute the upper-left corner:

```{r tile.1}
# Tile size, in integer degrees
size.long <- params$size; size.lat <- params$size
tile.ulc <- c(tile.lrc[1]-size.long, tile.lrc[2]+size.lat) # upper-left corner
m <- matrix(c(tile.ulc[1],tile.lrc[1],  #ulc
              tile.ulc[2], tile.lrc[2]  #lrc
              ),
            nrow=2)
bb.ll <- st_sfc(st_multipoint(m))
st_crs(bb.ll) <- 4326
print(bb.ll)
```

AOI in form needed for gNATSGO WCS import:

```{r wcs.aoi}
a <- c(tile.ulc[1],tile.lrc[2],  
              tile.lrc[1], tile.ulc[2] 
       )
```

A prefix for directories, to keep AOI results separate.

```{r aoi.dir.prefix}
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
                         "_lon", tile.ulc[1], tile.lrc[1])
```

A directory to store the map unit tile and its linked database on import:

```{r save.tile}
(dest.dir.gnatsgo.import <-  paste0(base.dir.gnatsgo.import, "/", 
                            AOI.dir.prefix))
if (!dir.exists(dest.dir.gnatsgo.import)) {
   dir.create(dest.dir.gnatsgo.import, recursive = TRUE)
}
```

A directory to save the processed tile:

```{r save.results}
dest.dir <-  paste0(base.dir.gnatsgo, "/", AOI.dir.prefix)
if (!dir.exists(dest.dir)) {
   dir.create(dest.dir, recursive = TRUE)
}
```

# WCS access


The 30~m product takes about 63Mb per spc. The default EPSG is 6350.

```{r get.tile, fig.cap="Map units at 30m"}
spc.name <- "mukey"
(spc.file <-  paste0(dest.dir.gnatsgo.import, "/", spc.name, ".grd"))
if (file.exists(spc.file)) {
  gn.30m <- raster(spc.file)
} else {
  system.time(
    gn.30m <- soilDB::mukey.wcs(var = 'gnatsgo', aoi = a, res = 30) # crs = "EPSG:6350"
  )
  names(gn.30m) <- "mukey"
  writeRaster(gn.30m, spc.file, format = "raster")  # extension  is .grd
}
crs(gn.30m)
bbox(gn.30m)
summary(gn.30m)
class(gn.30m)
rasterVis::levelplot(gn.30m, att = 'ID', margin = FALSE, colorkey = FALSE, ask=FALSE)
```

The colours are from the map unit ID, they have no other meaning.

Map unit IDs:

```{r}
length(unique(gn.30m))
ll <- levels(gn.30m)[[1]]
head(ll)
```

There are `r length(unique(gn.30m))` unique map unit IDs in this window.

# Attributes database

The Soil Data Access (SDA) web service has the information for each map unit. 
SDA from R is explained in [this tutorial](https://ncss-tech.github.io/AQP/soilDB/SDA-tutorial.html).

We have the map unit key, so get their information.

Query SDA by `mukey` for this tile.

This will bring down most of the interesting site / horizon level attributes from SSURGO/STATSGO

```{r}
spc.name <- "muinfo"
(spc.file <-  paste0(dest.dir.gnatsgo.import, "/", spc.name, ".rds"))
if (file.exists(spc.file)) {
  mu.info <- readRDS(spc.file)
} else {
  # Format vector of values into a string suitable for an SQL `IN` statement
  IS <- soilDB::format_SQL_in_statement(ll$ID)
  # query string -- all components
  ws <- sprintf("mukey IN %s", IS)
  system.time(
    mu.info <- suppressMessages(
      soilDB::fetchSDA(WHERE = ws, duplicates = TRUE, 
                       droplevels = TRUE, stringsAsFactors = FALSE,
                       childs = FALSE)
    )
  )
  saveRDS(mu.info, spc.file)
}
class(mu.info)
```


# Link to attribute of interest

Aggregate at component level for variable and depth interval of interest. For this we use the `aqp::slab()` function, "Aggregate soil properties along user-defined 'slabs', and optionally within groups".

Set up the depths and formula and then call the function:

```{r}
(slab.depths <- as.numeric(strsplit(depth.list.sg[params$depth.n],"-")[[1]]))
(slab.fm <- formula(paste0("cokey ~ ", voi.name)))
mu.attr <- aqp::slab(mu.info, slab.fm, 
            slab.structure = c(slab.depths[1], slab.depths[2]), 
            slab.fun = mean, na.rm = TRUE)
head(mu.attr)
warnings()[1]
```

Some of the map units have incorrect horizination.


Make an ID for reshaping; this is the same for all components:

```{r}
mu.attr$variable.id <- sprintf("%s%s%s", mu.attr$variable, mu.attr$top, mu.attr$bottom)
```

Long -> wide format as a dataframe with two columns: the component key and the attribute value in the depth slice.

```{r}
mu.attr.w <- reshape2::dcast(mu.attr, cokey ~ variable.id, value.var = 'value')
head(mu.attr.w)
```

Get the components of each map unit from the site information, via `aqp::site`, and then add the map unit key and proportions to the data frame:

```{r}
mu.site <- aqp::site(mu.info)[, c('mukey', 'cokey', 'comppct_r')]
mu.site <- base::merge(mu.site, mu.attr.w, by = 'cokey', sort = FALSE)
head(mu.site)
```


Look at the composition of the first map unit:

```{r}
head(mu.site)
mu.site.split <- split(mu.site, mu.site$mukey)
(tmp <- mu.site.split[[as.character(mu.site[1,"mukey"])]])
dim(tmp)
sum(tmp$comppct_r)
```

This has `dim(tmp)[1]` components; their proportion adds to `round(sum(tmp$comppct_r),1`%.

Now we have two ways to get properties from the map unit: weighted proportion or dominant component.

Function to weight the property by the component proportion.

Arguments:

* `i`: map unit ID
* `var.name`: the name of variable to weighted
* `wt.name`: the name of the field containing the component proportions

Implicit argument (in scope):

* `mu.site.split`: a separate data frame for each site

```{r}
wt.mean.component <- function(i = 1, var.name, wt.name = 'comppct_r') {
  
  # test
  i <- 1
  mu.i <- as.character(mu.site.split[[i]]$mukey)
  str(mu.i)
  mu.i[[1]]
  var.name <- "ph1to1h2o_r3060"
  mu.site.split[[i]][,var.name]
  wt.name = 'comppct_r'
  mu.site.split[[i]][,wt.name]

  # remove NA in target variable
  idx <- which(is.na(mu.site.split[[i]][,var.name]) | 
                 is.na(mu.site.split[[i]][,wt.name]))
  # length(idx)
  if(length(idx) > 0) {
    mu.i <- mu.i[-idx, ] 
  }
  

  #### TO HERE! 
  
  # list of components
  tmp <- mu.site.split[[mu.i]]

    # weighted mean
  wm <- sum(i[[var]] * i[[wt]]) / sum(i[[wt]])
  
  # pack results
  res <- data.frame(
    mukey = i$mukey[1],
    var = wm,
    stringsAsFactors = FALSE
  )
  
  # re-name for convenience later
  names(res)[2] <- var
  
  return(res)
}
```



# Save tile {#save}

Save this map for further processing, e.g., comparing with SoilGrids250 or other PSM products.

Save the tile. Note that the file name includes the property name and depth slice. Specify the integer datatype and a GeoTIFF "world" file.

```{r}
f <- terra::writeRaster(r.attr, file=paste0(dest.dir, "/gNATSGO_",
                                              voi.depth.name, ".tif"),
                        overwrite=TRUE, datatype="INT2U", options=c("TFW=YES"),
                        filetype="GTIFF")
print(f)
```


  
