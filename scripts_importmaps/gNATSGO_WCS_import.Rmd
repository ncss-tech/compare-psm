---
title: "gNATSGO -- Import via WCS for PSM comparisons"
author:
  - "D G Rossiter"
  - "d.g.rossiter@cornell.edu"
date: "`r format(Sys.Date(), '%d-%B-%Y')`"
params:
   lrc_long: -76
   lrc_lat: 42 
   size: 1
   quantile.n: NA
   voi.n: 4
   depth.n: 4
output:
  html_document:
    fig_align: center
    fig_height: 6
    fig_width: 6
    fig_caption: false
    number_section: yes
    theme: spacelab
    df_print: paged
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      purl=FALSE, 
                      fig.align = 'center')
knitr::opts_chunk$set(cache.extra = R.version.string, comment="")
```

# Introduction

[gNATSGO](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/survey/geo/?cid=nrcseprd1464625) "is a USDA-NRCS Soil & Plant Science Division (SPSD) composite database that provides complete coverage of the best available soils information for all areas of the United States and Island Territories. It was created by combining data from the Soil Survey Geographic Database (SSURGO), State Soil Geographic Database (STATSGO2), and Raster Soil Survey Databases (RSS) offsite link image into a single seamless ESRI file geodatabase."

It is thus the most authoritative digital product, representing many decades of field work and subsequent compilation.

A description (more or less) is [here](https://nrcs.app.box.com/v/soils/file/744008197230). Unfortunately the instructions are for an ArcInfo toolkit "gSSURGO tools", and it applies to the State-wide products, not the CONUS product.

Web Coverage Service (WCS) access is now provided by NRCS; we use that in this script.

This script creates a tile for a property and depth slice, over a Area of Interest delimited by geographic coordinates, that can then be compared with other PSM products. 

To use this script:

Steps 1--4 refer to the YAML headers, or external calls with `knitr::render`.

1. Ajust the [directory structure](#dirs) to your system

2. [Select a property](#prop) and [select a depth slice](#depth), using the YAML header or by knitting with parameters.

3. [Select an Area of Interest](#aoi), using the YAML header or by knitting with parameters.

4. Either compile to HTML or PDF ("knit"), or "Run All" within R Markdown.

5. The processed tile will be in the directory structure, in a [subdirectory named for the AOI](#save).

# Packages and Drivers

```{r pack}
library(sf)
library(sp)
library(rgdal)
library(aqp)
library(soilDB)
library(tidyverse)
# library(terra) 
library(raster) 
library(rasterVis)
``` 


# Directories {#dirs}

One directory is used for the large original files (all-CONUS grid and all-map unit database), and another for the extracted tiles. Set these to areas on your own system.

```{r}
base.dir.gnatsgo <- "/Users/rossiter/ds/gNATSGO"
base.dir.gnatsgo.import <- "/Volumes/Pythagoras/ds/gNATSGO"
```

# WCS Access



# Attribute database

 
CRS is a CONUS Albers Equal Area.



# Parameters

Parameters for this run:

```{r}
print(paste("lrc_long:", params$lrc_long, "; lrc_lat:", params$lrc_lat, "; size:", params$size))
print(paste("voi.n:", params$voi.n, "; depth.n:", params$depth.n))
```

## Property of interest {#prop}

The following properties can be compared to SoilGrids250 and other PSM products.

*** Check the gNATSGO list.

```{r voi.list}
voi.list.sg <- c("clay", "silt", "sand", "phh2o", "cec", "soc", "bdod", "cfvo")
voi.list.gnatsgo <- c("clay", "silt", "sand",
                  "ph", "cec", "soc", 
                  "", "")
```

*Select a property* by its position in the list, and make a full name from it:

```{r voi}
(voi.name <- voi.list.gnatsgo[params$voi.n])
```


## Depth of interest {#depth}

```{r depth.list}
depth.list.sg <- c("0-5", "5-15", "15-30", "30-60", "60-100", "100-200")
depth.list.gnatsgo <- c("05", "515", "1530", "3060", "60100", "100200")
```

*Select a depth slice* by its position in the list, based on the YAML or run-time parameter, and make a full name from the property of interest and the selected depth slice:

```{r depth}
depth.gnatsgo <- depth.list.gnatsgo[params$depth.n]
(voi.depth.name <- paste0(voi.name, "_", depth.gnatsgo, "cm"))
```


## Area of Interest (AOI) {#aoi}

Specify the lower-right corner from the YAML or rendering parameters:

```{r lrc}
tile.lrc <- c(params$lrc_long, params$lrc_lat) # lower-right corner
```

Compute the upper-left corner:

```{r tile.1}
# Tile size, in integer degrees
size.long <- params$size; size.lat <- params$size
tile.ulc <- c(tile.lrc[1]-size.long, tile.lrc[2]+size.lat) # upper-left corner
m <- matrix(c(tile.ulc[1],tile.lrc[1],  #ulc
              tile.ulc[2], tile.lrc[2]  #lrc
              ),
            nrow=2)
bb.ll <- st_sfc(st_multipoint(m))
st_crs(bb.ll) <- 4326
```

AOI in form needed for gNATSGO WCS import:

```{r wcs.aoi}
a <- c(tile.ulc[1],tile.lrc[2],  
              tile.lrc[1], tile.ulc[2] 
       )
```

# WCS access


The 30~m product takes about 63Mb per tile. The default EPSG is 6350.

```{r get.tile, fig.cap="Map units at 30m"}
# mukey.wcs(var = "gnatsgo", aoi, res = 30, crs = "EPSG:6350")
gn.30m <- soilDB::mukey.wcs(var = 'gnatsgo', aoi = a, res = 30)
names(gn.30m) <- "mukey"
crs(gn.30m)
bbox(gn.30m)
summary(gn.30m)
class(gn.30m)
rasterVis::levelplot(gn.30m, att = 'ID', margin = FALSE, colorkey = FALSE, ask=FALSE)
```

Map unit IDs:

```{r}
length(unique(gn.30m))
ll <- levels(gn.30m)[[1]]
head(ll)
```

There are `r length(unique(gn.30m))` unique map unit IDs in this window.

# Attributes database

The Soil Data Access (SDA) web service has the information for each map unit. 
SDA from R is explained in [this tutorial](https://ncss-tech.github.io/AQP/soilDB/SDA-tutorial.html).

We have the map unit key, so get their information.

Query SDA by `mukey`.

This will bring down most of the interesting site / horizon level attributes from SSURGO/STATSGO

```{r}
# Format vector of values into a string suitable for an SQL `IN` statement
IS <- soilDB::format_SQL_in_statement(ll$ID)
# query string
ws <- sprintf("mukey IN %s", IS)
mu.info <- soilDB::fetchSDA(WHERE = ws, duplicates = TRUE, droplevels = TRUE, stringsAsFactors = FALSE)
class(mu.info)
```


# Link to attribute of interest

Aggregate at component level for variable and depth interval of interest. For this we use the `aqp::slab()` function, "Aggregate soil properties along user-defined 'slabs', and optionally within groups".

Note that we get an "extra" depth interval of 5-30

```{r}
x.a <- aqp::slab(mu.info, cokey ~ ph1to1h2o_r + claytotal_r, 
            slab.structure = c(0, 5, 30, 60), 
            slab.fun = mean, na.rm = TRUE)
```



# Save tile {#save}

Save this map for further processing, e.g., comparing with SoilGrids250 or other PSM products.

A prefix for directories, to keep AOI results separate.

```{r}
AOI.dir.prefix <- paste0("lat", tile.lrc[2], tile.ulc[2],
                         "_lon", tile.ulc[1], tile.lrc[1])
```

A directory to store the tile:

```{r save}
dest.dir <-  paste0(base.dir.gnatsgo, AOI.dir.prefix)
if (!dir.exists(dest.dir)) {
   dir.create(dest.dir, recursive = TRUE)
}
```

Save the tile. Note that the file name includes the property name and depth slice. Specify the integer datatype and a GeoTIFF "world" file.

```{r}
f <- terra::writeRaster(r.attr, file=paste0(dest.dir, "/GSM_",
                                              voi.depth.name, ".tif"),
                        overwrite=TRUE, datatype="INT2U", options=c("TFW=YES"),
                        filetype="GTIFF")
print(f)
```


  
